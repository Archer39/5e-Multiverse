{"name":"Form of Dread","type":"feat","img":"icons/magic/unholy/silhouette-robe-evil-glow.webp","system":{"description":{"value":"<div>You manifest an aspect of your patron’s dreadful power. As a bonus action, you transform for 1 minute. You gain the following benefits while transformed:</div>\n<ul>\n<li>You gain temporary hit points equal to 1d10 + your warlock level.</li>\n<li>Once during each of your turns, when you hit a creature with an attack roll, you can force it to make a Wisdom saving throw, and if the saving throw fails, the target is frightened of you until the end of your next turn.</li>\n<li>You are immune to the frightened condition.</li>\n<li>You can transform a number of times equal to your proficiency bonus, and you regain all expended uses when you finish a long rest.</li>\n</ul>\n<div>The appearance of your Form of Dread reflects some aspect of your patron. For example, your form could be a shroud of shadows forming the crown and robes of your lich patron, or your body might glow with glyphs from ancient funerary rites and be surrounded by desert winds, suggesting your mummy patron.</div>","chat":"","unidentified":""},"source":"","activation":{"type":"bonus","cost":1,"condition":""},"duration":{"value":1,"units":"minute"},"target":{"value":null,"width":null,"units":"","type":"self"},"range":{"value":null,"long":null,"units":"self"},"uses":{"value":2,"max":"@prof","per":"lr","recovery":""},"consume":{"type":"","target":"","amount":null},"ability":"","actionType":"util","attackBonus":0,"chatFlavor":"","critical":{"threshold":null,"damage":""},"damage":{"parts":[["1d10[temphp] + @classes.warlock.levels","temphp"]],"versatile":""},"formula":"","save":{"ability":"","dc":null,"scaling":"spell"},"requirements":"Warlock 1","recharge":{"value":null,"charged":false}},"effects":[{"_id":"jqibv1icxx6jynnc","changes":[{"key":"flags.dnd5e.DamageBonusMacro","mode":0,"value":"ItemMacro.Form of Dread","priority":20},{"key":"system.traits.ci.value","mode":0,"value":"frightened","priority":20}],"disabled":false,"duration":{"startTime":null,"seconds":null,"combat":null,"rounds":null,"turns":null,"startRound":null,"startTurn":null},"icon":"icons/magic/unholy/silhouette-robe-evil-glow.webp","label":"Form of Dread","transfer":false,"flags":{"dae":{"selfTarget":false,"stackable":"none","durationExpression":"","macroRepeat":"none","specialDuration":[],"transfer":false},"core":{"statusId":""},"dnd5e-helpers":{"rest-effect":"Ignore"},"ActiveAuras":{"isAura":false,"aura":"None","radius":null,"alignment":"","type":"","ignoreSelf":false,"height":false,"hidden":false,"displayTemp":false,"hostile":false,"onlyOnce":false}},"tint":null,"origin":null}],"flags":{"magicitems":{"enabled":false,"equipped":false,"attuned":false,"charges":"0","chargeType":"c1","destroy":false,"destroyFlavorText":"reaches 0 charges: it crumbles into ashes and is destroyed.","rechargeable":false,"recharge":"0","rechargeType":"t1","rechargeUnit":"r1","sorting":"l"},"itemacro":{"macro":{"data":{"_id":null,"name":"Form of Dread","type":"script","author":"Tyd5yiqWrRZMvG30","img":"icons/svg/dice-target.svg","scope":"global","command":"if (args[0].tag === \"DamageBonus\") {\n    const lastArg = args[args.length - 1];\n    let tokenD = canvas.tokens.get(lastArg.tokenId);\n    let actorD = tokenD.actor;\n    let actorData = actorD.getRollData();\n    let target = await fromUuid(lastArg.hitTargets[0].uuid);\n    if (![\"ak\"].some(i => (lastArg.item.data.actionType).toLowerCase().includes(i))) return {};\n    let itemD = actorD.items.getName(\"Form of Dread\");\n    if (actorD.effects.find(i => i.data.label === `${itemD.name} Attack`)) return {};\n    let gameRound = game.combat ? game.combat.round : 0;\n    let effectData = {\n        label: `${itemD.name} Attack`,\n        icon: \"icons/magic/death/skull-energy-light-purple.webp\",\n        tint: \"#ff0000\",\n        origin: itemD.uuid,\n        duration: { turns: 1, startRound: gameRound, startTime: game.time.worldTime }\n    };\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: actorD.uuid, effects: [effectData] });\n    let immunity = [\"frightened\"];\n    let getImmunity = target.actor.getRollData().traits.ci.value.find(i => immunity.includes(i));\n    let resist = [\"Magic Resistance\"];\n    let getResistance = target.actor.items.find(i => resist.includes(i.name));\n    let getAdvantage = getResistance ? { advantage: true, chatMessage: false, fastForward: true } : { chatMessage: false, fastForward: true };\n    let saveType = \"wis\";\n    let save = await MidiQOL.socket().executeAsGM(\"rollAbility\", { request: \"save\", targetUuid: target.actor.uuid, ability: saveType, options: getAdvantage });\n    let success = \"saves\";\n    console.log(save.total, actorData.attributes.spelldc,getImmunity)\n    if(getImmunity) {\n        save.total = 99;\n    }\n    if (save.total < actorData.attributes.spelldc) {\n        success = \"fails\";\n        let condition = \"Frightened\";\n        let conditionIcon = \"icons/svg/terror.svg\";\n        let conditionFlags = { \"dae\": { \"token\": target.actor.uuid, specialDuration: [\"turnEndSource\"] } };\n        if ((game.modules.get(\"combat-utility-belt\")) && (game.modules.get(\"combat-utility-belt\")?.active)) {\n            let cubCondition = game.cub?.conditions?.find(i => i.name === condition);\n            if (cubCondition) {\n                conditionIcon = cubCondition.icon;\n                conditionFlags[\"combat-utility-belt\"] = { \"conditionId\": cubCondition.id, \"overlay\": false };\n                conditionFlags[\"core\"] = { \"statusId\": `combat-utility-belt.${cubCondition.id}` };\n            }\n        }\n        let targetEffectData = {\n            label: condition,\n            icon: conditionIcon,\n            origin: itemD.uuid,\n            disabled: false,\n            flags: conditionFlags,\n            duration: {rounds:1, turns: 2, startRound: gameRound, startTime: game.time.worldTime },\n            changes: [{ key: `flags.midi-qol.disadvantage.ability.check.all`, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: 1, priority: 20 },\n            { key: `flags.midi-qol.disadvantage.skill.all`, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: 1, priority: 20 },\n            { key: `flags.midi-qol.disadvantage.attack.all`, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: 1, priority: 20 }]\n        };\n        let effect = target.actor.effects.find(i => i.data.label === condition);\n        if (!effect) {\n            await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: target.actor.uuid, effects: [targetEffectData] });\n        }\n    }\n    let targetResult = `<div class=\"midi-qol-flex-container\"><div class=\"midi-qol-target-npc midi-qol-target-name\" id=\"${target.id}\">${target.actor.name} ${success} with ${save.total}</div><div><img src=\"${target.data.img}\" width=\"30\" height=\"30\" style=\"border:0px\"></div></div>`;\n    let saveResult = `<div class=\"midi-qol-nobox midi-qol-bigger-text\">${CONFIG.DND5E.abilities[saveType]} Saving Throw: DC ${actorData.attributes.spelldc}</div><div><div class=\"midi-qol-nobox\">${targetResult}</div></div>`;\n    let chatMessage = await game.messages.get(lastArg.itemCardId);\n    let content = await duplicate(chatMessage.data.content);\n    let searchString = /<div class=\"midi-qol-saves-display\">[\\s\\S]*<div class=\"end-midi-qol-saves-display\">/g;\n    let replaceString = `<div class=\"midi-qol-saves-display\"><div class=\"end-midi-qol-saves-display\">${saveResult}`;\n    content = await content.replace(searchString, replaceString);\n    await chatMessage.update({ content: content });\n    await ui.chat.scrollBottom();\n}","folder":null,"sort":0,"permission":{"default":0},"flags":{}},"_id":null,"name":"Form of Dread","type":"script","author":"Tyd5yiqWrRZMvG30","img":"icons/svg/dice-target.svg","scope":"global","command":"if (args[0].tag === \"DamageBonus\") {\n    const lastArg = args[args.length - 1];\n    const version = Math.floor(game.version);\n    let tokenD = canvas.tokens.get(lastArg.tokenId);\n    let actorD = tokenD.actor;\n    let actorData = actorD.getRollData();\n    let target = await fromUuid(lastArg.hitTargets[0].uuid);\n    if (![\"ak\"].some(i => (lastArg.item.data.actionType).toLowerCase().includes(i))) return {};\n    let itemD = actorD.items.getName(\"Form of Dread\");\n    if (actorD.effects.find(i => (version > 9 ? i.label : i.data.label) === `${itemD.name} Attack`)) return {};\n    let gameRound = game.combat ? game.combat.round : 0;\n    let effectData = {\n        label: `${itemD.name} Attack`,\n        icon: \"icons/magic/death/skull-energy-light-purple.webp\",\n        tint: \"#ff0000\",\n        transfer: false,\n        origin: itemD.uuid,\n        duration: { turns: 1, startRound: gameRound, startTime: game.time.worldTime }\n    };\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: actorD.uuid, effects: [effectData] });\n    let immunity = [\"frightened\"];\n    let getImmunity = target.actor.getRollData().traits.ci.value.find(i => immunity.includes(i));\n    let resist = [\"Magic Resistance\"];\n    let getResistance = target.actor.items.find(i => resist.includes(i.name));\n    let getAdvantage = getResistance ? { advantage: true, chatMessage: false, fastForward: true } : { chatMessage: false, fastForward: true };\n    let saveType = \"wis\";\n    let save = await MidiQOL.socket().executeAsGM(\"rollAbility\", { request: \"save\", targetUuid: target.actor.uuid, ability: saveType, options: getAdvantage });\n    let success = \"saves\";    \n    if(getImmunity) {\n        save.total = 99;\n    }\n    if (save.total < actorData.attributes.spelldc) {\n        success = \"fails\";\n        let condition = \"Frightened\";\n        let conditionIcon = \"icons/svg/terror.svg\";\n        let conditionFlags = { \"dae\": { \"token\": target.actor.uuid, specialDuration: [\"turnEndSource\"] } };\n        if ((game.modules.get(\"combat-utility-belt\")) && (game.modules.get(\"combat-utility-belt\")?.active)) {\n            let cubCondition = game.cub?.conditions?.find(i => i.name === condition);\n            if (cubCondition) {\n                conditionIcon = cubCondition.icon;\n                conditionFlags[\"combat-utility-belt\"] = { \"conditionId\": cubCondition.id, \"overlay\": false };\n                conditionFlags[\"core\"] = { \"statusId\": `combat-utility-belt.${cubCondition.id}` };\n            }\n        }\n        let targetEffectData = {\n            label: condition,\n            icon: conditionIcon,\n            origin: itemD.uuid,\n            disabled: false,\n            flags: conditionFlags,\n            duration: { startRound: gameRound, startTime: game.time.worldTime },\n            changes: [{ key: `flags.midi-qol.disadvantage.ability.check.all`, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: 1, priority: 20 },\n            { key: `flags.midi-qol.disadvantage.skill.all`, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: 1, priority: 20 },\n            { key: `flags.midi-qol.disadvantage.attack.all`, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: 1, priority: 20 }]\n        };\n        let effect = target.actor.effects.find(i => (version > 9 ? i.label : i.data.label) === condition);\n        if (!effect) {\n            await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: target.actor.uuid, effects: [targetEffectData] });\n        }\n    }\n    let targetResult = `<div class=\"midi-qol-flex-container\"><div class=\"midi-qol-target-npc midi-qol-target-name\" id=\"${target.id}\">${target.actor.name} ${success} with ${save.total}</div><div><img src=\"${version > 9 ? target.texture.src : target.data.img}\" width=\"30\" height=\"30\" style=\"border:0px\"></div></div>`;\n    let saveResult = `<div class=\"midi-qol-nobox midi-qol-bigger-text\">${CONFIG.DND5E.abilities[saveType]} Saving Throw: DC ${actorData.attributes.spelldc}</div><div><div class=\"midi-qol-nobox\">${targetResult}</div></div>`;\n    let chatMessage = await game.messages.get(lastArg.itemCardId);\n    let content = await duplicate((version > 9 ? chatMessage.content : chatMessage.data.content));\n    let searchString = /<div class=\"midi-qol-saves-display\">[\\s\\S]*<div class=\"end-midi-qol-saves-display\">/g;\n    let replaceString = `<div class=\"midi-qol-saves-display\"><div class=\"end-midi-qol-saves-display\">${saveResult}`;\n    content = await content.replace(searchString, replaceString);\n    await chatMessage.update({ content: content });\n    await ui.chat.scrollBottom();\n}","folder":null,"sort":0,"permission":{"default":0},"flags":{}}},"midi-qol":{"effectActivation":false,"onUseMacroName":"","forceCEOn":false,"forceCEOff":true},"midiProperties":{"nodam":false,"fulldam":false,"halfdam":false,"rollOther":false,"critOther":false,"magicdam":false,"magiceffect":false,"concentration":false,"toggleEffect":false},"core":{"sourceId":"Item.fHht97Ravwp17UcM"},"exportSource":{"world":"darklands","system":"dnd5e","coreVersion":"9.280","systemVersion":"1.6.3"}},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":1669440918461,"modifiedTime":1669440918461,"lastModifiedBy":"T4cu5jv0VXcrhb1w"},"_id":"08R51caFBXJV5jpV","folder":null,"sort":0,"ownership":{"default":0,"T4cu5jv0VXcrhb1w":3}}
{"name":"Channel Divinity: Turn Undead","type":"feat","img":"icons/magic/fire/flame-burning-creature-skeleton.webp","system":{"description":{"value":"<p class=\"Core-Styles_Core-Body\">As an action, you present your holy symbol and speak a prayer censuring the undead. Each undead that can see or hear you within 30 feet of you must make a Wisdom saving throw. If the creature fails its saving throw, it is turned for 1 minute or until it take<span class=\"No-Break\">s any damage.</span></p>\n<p class=\"Core-Styles_Core-Body\">A turned creature must spend its turns trying to move as far away from you as it can, and it can’t willingly move to a space within 30 feet of you. It also can’t take reactions. For its action, it can use only the <span class=\"No-Break\">Dodge action.</span></p>","chat":"As an action, you present your holy symbol and speak a prayer censuring the undead. Each undead that can see or hear you within 30 feet of you must make a WIS saving throw (DC +13). If the creature fails its saving throw, it is turned for 1 minute or until it takes any damage. A turned creature must spend its turns trying to move as far away from you as it can, and it can’t willingly move to a space within 30 feet of you. It also can’t take reactions. For its action, it can use only the Dash action or try to escape from an effect that prevents it from moving. If there’s nowhere to move, the creature can use the Dodge action.","unidentified":""},"source":"","activation":{"type":"action","cost":1,"condition":""},"duration":{"value":null,"units":""},"target":{"value":30,"width":null,"units":"ft","type":"creature"},"range":{"value":null,"long":null,"units":"spec"},"uses":{"value":null,"max":"","per":"","recovery":""},"consume":{"type":"attribute","target":"","amount":1},"ability":"","actionType":"other","attackBonus":0,"chatFlavor":"","critical":{"threshold":null,"damage":null},"damage":{"parts":[],"versatile":""},"formula":"","save":{"ability":"","dc":null,"scaling":"spell"},"requirements":"Cleric 2","recharge":{"value":null,"charged":false}},"effects":[],"flags":{"ddbimporter":{"id":"74143","entityTypeId":"222216831","componentId":110,"componentTypeId":12168134,"dndbeyond":{"levelScale":null,"levelScales":[],"limitedUse":[{"level":null,"uses":1},{"level":null,"uses":1}]}},"itemacro":{"macro":{"data":{"_id":null,"name":"Channel Divinity: Turn Undead","type":"script","author":"Tyd5yiqWrRZMvG30","img":"icons/svg/dice-target.svg","scope":"global","command":"/////////////////////////////////////////////////\n// READ FIRST\n// Requires: Callback macros ActorUpdate\n////////////////////////////////////////////////\nasync function wait(ms) { return new Promise(resolve => { setTimeout(resolve, ms); }); }\nasync function cr_lookup(level) {\n    return level > 20 ? 5 : level >= 17 ? 4 : level >= 14 ? 3 : level >= 11 ? 2 : level >= 8 ? 1 : level >= 5 ? 0.5 : 0;\n}\nif (!game.modules.get(\"warpgate\")?.active) return ui.notifications.error(\"Turn Undead requires warpgate module\");\n\nconst lastArg = args[args.length - 1];\nconst actorD = canvas.tokens.get(lastArg.tokenId).actor;\nconst rollData = actorD.getRollData();\nconst level = rollData.details.cr ?? rollData.classes.cleric.levels;\nconst DC = rollData.attributes.spelldc;\nconst saveType = rollData.attributes.spellcasting;\nconst itemD = lastArg.item;\nconst gameRound = game.combat ? game.combat.round : 0;\n\nconsole.warn(`###### ${itemD.name} Workflow Started #####`);\n\nconst targetList = lastArg.targets.reduce((list, target) => {\n    let creatureTypes = [\"undead\"];\n    let undead = target.actor.type === \"character\" ? creatureTypes.some(i => (target.actor.data.data.details.race).toLowerCase().includes(i)) : creatureTypes.some(i => (target.actor.data.data.details.type.value).toLowerCase().includes(i));\n    if (!undead && target.actor.type === \"character\" && target.actor.data.data.details.race === (undefined || null)) {\n        console.error(`=>`, `Invalid Target`, target.name, `| Skipped: Race mismatch`, `| Result:`, target.actor.data.data.details.race);\n        return list;\n    } else if (!undead && target.actor.type === \"npc\" && target.actor.data.data.details.type.value === (undefined || null)) {\n        console.error(`=>`, `Invalid Target`, target.name, `| Skipped: Type mismatch`, `| Result:`, target.actor.data.data.details.type.value);\n        return list;\n    } else if (!undead && target.actor.type === \"npc\" && target.actor.data.data.details.type.value === \"custom\") {\n        undead = creatureTypes.some(i => (target.actor.data.data.details.type.subtype || target.actor.data.data.details.type.custom).toLowerCase().includes(i));\n        if (!undead) {\n            console.error(`=>`, `Invalid Target`, target.name, `| Skipped: Custom Type mismatch`, `| Result:`, target.actor.data.data.details.type.custom, `(${target.actor.data.data.details.type.subtype})`);\n            return list;\n        }\n    };\n    console.warn(`=>`, `Target Found:`, target.name, `| Creature Type:`, target.actor.type === \"character\" ? target.actor.data.data.details.race : target.actor.data.data.details.type.value);\n    if (undead) list.push(target);\n    return list;\n}, []);\n\nif (targetList.length === 0) {\n    ui.notifications.warn(`${itemD.name} was unable to find any valid targets`);\n    console.error(`${itemD.name} was unable to find any valid targets`);\n    return console.error(`##### ${itemD.name} Workflow Aborted #####`);\n}\n\nlet turnTargets = [];\n\nfor (let target of targetList) {\n    let mon_cr = target.actor.getRollData().details.cr;\n    let level_cr = await cr_lookup(level);\n    // add turn resist terms\n    let resist = [\"Turn Resistance\", \"Turn Defiance\"];\n    let getResistance = target.actor.items.find(i => resist.includes(i.name));\n    let immunity = [\"Turn Immunity\"];\n    let getImmunity = target.actor.items.find(i => immunity.includes(i.name));\n    let getAdvantage = getResistance ? { advantage: true, chatMessage: false, fastForward: true } : { chatMessage: false, fastForward: true };\n    let save = await MidiQOL.socket().executeAsGM(\"rollAbility\", { request: \"save\", targetUuid: target.actor.uuid, ability: saveType, options: getAdvantage });\n    if (getImmunity) {\n        console.warn(`=>`, `Target Processed:`, target.name, `| CR:`, mon_cr, `| Result: Immune`);\n        turnTargets.push(`<div class=\"midi-qol-flex-container\"><div class=\"midi-qol-target-npc midi-qol-target-name\" id=\"${target.id}\">${target.name} is immune</div><div><img src=\"${target.data.img}\" width=\"30\" height=\"30\" style=\"border:0px\"></div></div>`);\n    } else {\n        if (save.total < DC) {\n            if (level_cr >= mon_cr) {\n                console.warn(`=>`, `Target Processed:`, target.name, `| CR:`, mon_cr, `| DC:`, DC, `| Save:`, save.total, `[Fail]`, `| Result: Destroyed`);\n                turnTargets.push(`<div class=\"midi-qol-flex-container\"><div class=\"midi-qol-target-npc midi-qol-target-name\" id=\"${target.id}\">${target.name} fails with ${save.total} [D]</div><div><img src=\"${target.data.img}\" width=\"30\" height=\"30\" style=\"border:0px\"></div></div>`);\n                let maxHP = Number(target.actor.data.data.attributes.hp.max);\n                let updates = {\n                    actor: { \"data.attributes.hp.value\": 0, \"data.attributes.hp.max\": maxHP }\n                };\n                let mutateCallbacks = \"\";\n                await warpgate.mutate(target, updates, mutateCallbacks, { permanent: true });\n            } else {                \n                let condition = game.i18n.localize(\"Frightened\");\n                let conditionIcon = \"icons/svg/terror.svg\";\n                let conditionFlags = { \"dae\": { \"token\": target.actor.uuid } };\n                if (game.modules.get(\"combat-utility-belt\")?.active) {\n                    let cubCondition = game.cub?.conditions?.find(i => i.name === condition);\n                    if (cubCondition) {\n                        conditionIcon = cubCondition.icon;\n                        conditionFlags[\"combat-utility-belt\"] = { \"conditionId\": cubCondition.id, \"overlay\": false };\n                        conditionFlags[\"core\"] = { \"statusId\": `combat-utility-belt.${cubCondition.id}` };\n                    }\n                }\n                console.warn(`=>`, `Target Processed:`, target.name, `| CR:`, mon_cr, `| DC:`, DC, `| Save:`, save.total, `[Fail]`, `| Result: ${condition}`);\n                let effectData = {\n                    label: condition,\n                    icon: conditionIcon,\n                    origin: lastArg.uuid,\n                    disabled: false,\n                    flags: { dae: { specialDuration: [\"isDamaged\"] } },\n                    duration: { rounds: 10, startRound: gameRound, startTime: game.time.worldTime },\n                    changes: [{ key: `flags.midi-qol.disadvantage.ability.check.all`, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: 1, priority: 20 },\n                    { key: `flags.midi-qol.disadvantage.skill.all`, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: 1, priority: 20 },\n                    { key: `flags.midi-qol.disadvantage.attack.all`, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: 1, priority: 20 }]\n                };\n                let effect = target.actor.effects.find(i => i.data.label === condition);\n                if (!effect) {\n                    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: target.actor.uuid, effects: [effectData] });\n                    console.warn(`>`, target.name, `Applyying: ${condition} Condition`, `Success`);\n                } else {\n                    console.error(`>`, target.name, `Applyying: ${condition} Condition`, `Failure`);\n                }\n                turnTargets.push(`<div class=\"midi-qol-flex-container\"><div class=\"midi-qol-target-npc midi-qol-target-name\" id=\"${target.id}\">${target.name} fails with ${save.total} [F]</div><div><img src=\"${target.data.img}\" width=\"30\" height=\"30\" style=\"border:0px\"></div></div>`);\n            }\n        } else {\n            console.warn(`=>`, `Target Skipped:`, target.name, `| CR:`, mon_cr, `| DC:`, DC, `| Save:`, save.total, `[Skipped]`, `| Result: Save`);\n            turnTargets.push(`<div class=\"midi-qol-flex-container\"><div class=\"midi-qol-target-npc midi-qol-target-name\" id=\"${target.id}\">${target.name} saves with ${save.total}</div><div><img src=\"${target.data.img}\" width=\"30\" height=\"30\" style=\"border:0px\"></div></div>`);\n        }\n    }\n}\nconsole.warn(`##### ${itemD.name} Workflow Completed #####`);\nawait wait(600);\nlet turn_results = `<div class=\"midi-qol-nobox midi-qol-bigger-text\">${CONFIG.DND5E.abilities[saveType]} Saving Throw: DC ${DC}</div><div><div class=\"midi-qol-nobox\">${turnTargets.join('')}</div></div>`;\nlet chatMessage = await game.messages.get(lastArg.itemCardId);\nlet content = await duplicate(chatMessage.data.content);\nlet searchString = /<div class=\"midi-qol-hits-display\">[\\s\\S]*<div class=\"end-midi-qol-hits-display\">/g;\nlet replaceString = `<div class=\"midi-qol-hits-display\"><div class=\"end-midi-qol-hits-display\">${turn_results}`;\ncontent = await content.replace(searchString, replaceString);\nawait chatMessage.update({ content: content });\nawait ui.chat.scrollBottom();","folder":null,"sort":0,"permission":{"default":0},"flags":{}},"_id":null,"name":"Channel Divinity: Turn Undead","type":"script","author":"Tyd5yiqWrRZMvG30","img":"icons/svg/dice-target.svg","scope":"global","command":"/////////////////////////////////////////////////\n// READ FIRST\n// Requires: Callback macros ActorUpdate\n////////////////////////////////////////////////\nasync function wait(ms) { return new Promise(resolve => { setTimeout(resolve, ms); }); }\nasync function cr_lookup(level) { return level > 20 ? 5 : level >= 17 ? 4 : level >= 14 ? 3 : level >= 11 ? 2 : level >= 8 ? 1 : level >= 5 ? 0.5 : 0; }\n\nif ((!game.modules.get(\"warpgate\")) && (!game.modules.get(\"warpgate\")?.active)) return ui.notifications.error(\"Turn Undead requires warpgate module\");\n\nconst lastArg = args[args.length - 1];\nconst version = Math.floor(game.version);\nconst actorD = canvas.tokens.get(lastArg.tokenId).actor;\nconst rollData = actorD.getRollData();\nconst level = Number((rollData.details?.cr) || (rollData.classes?.cleric?.levels));\nconst DC = rollData.attributes.spelldc;\nconst saveType = rollData.attributes.spellcasting;\nconst itemD = lastArg.item;\nconst gameRound = game.combat ? game.combat.round : 0;\nconst ravenKindSymbol = actorD.items.find(i=> i.name === \"Holy Symbol of Ravenkind\");\nlet holySymbol;\n\nconsole.warn(`###### ${itemD.name} Workflow Started #####`);\n\nconst targetList = lastArg.targets.reduce((list, target) => {\n    let creatureTypes = [\"undead\"];\n    let targetData = target.actor.getRollData();\n    let undead = creatureTypes.some(i => (targetData.details?.type?.custom)?.toLowerCase()?.includes(i) || (targetData.details?.type?.value)?.toLowerCase()?.includes(i) || (targetData.details?.race)?.toLowerCase()?.includes(i));\n    if (!undead) {\n        console.error(`=>`, `Invalid Target`, target.name, `| Skipped: Race / Creature Type no match`, `| Result:`, ((targetData.details?.type?.custom) || (targetData.details?.type?.value) || (targetData.details?.race)));\n        return list;\n    } else {\n        console.warn(`=>`, `Target Found:`, target.name, `| Creature Type:`, ((targetData.details?.type?.custom) || (targetData.details?.type?.value) || (targetData.details?.race)));\n    }\n    if (undead) list.push(target);\n    return list;\n}, []);\n\nif (targetList.length === 0) {\n    ui.notifications.warn(`${itemD.name} was unable to find any valid targets, F12 to check console log.`);\n    console.error(`${itemD.name} was unable to find any valid targets`);\n    return console.error(`##### ${itemD.name} Workflow Aborted #####`);\n}\n\nif(ravenKindSymbol){\nholySymbol = await new Promise((resolve) => {\n    new Dialog({\n        title: ravenKindSymbol.name,\n        content: `<p>Did you spend a charge?</p>`,\n        buttons: {\n            yes: {                \n                label: \"Yes\",\n                callback: async () => resolve(true)\n            },\n            no: {\n                label: \"No\",\n                callback: async () => resolve(false)\n            }\n        },\n        default: \"No\"\n    }).render(true);\n});\n}\n\nlet turnTargets = [];\n\nfor (let target of targetList) {\n    let targetData = target.actor.getRollData();\n    let mon_cr = targetData.details.cr;\n    let level_cr = await cr_lookup(level);\n    // add turn resist terms\n    let resist = [\"Turn Resistance\", \"Turn Defiance\"];\n    let getResistance = target.actor.itemTypes.feat.find(i => resist.includes(i.name));\n    let immunity = [\"Turn Immunity\"];\n    let getImmunity = target.actor.itemTypes.feat.find(i => immunity.includes(i.name));    \n    let getAdvantage = getResistance ? { advantage: true, chatMessage: false, fastForward: true } : { chatMessage: false, fastForward: true };\n    let holysymbolEffect = holySymbol ? getResistance ? { chatMessage: false, fastForward: true } : { disadvantage: true, chatMessage: false, fastForward: true } : getAdvantage;    \n    if (getImmunity) {\n        console.warn(`=>`, `Target Processed:`, target.actor.name, `| CR:`, mon_cr, `| Result: Immune`);\n        turnTargets.push(`<div class=\"midi-qol-flex-container\"><div class=\"midi-qol-target-npc midi-qol-target-name\" id=\"${target.id}\">${target.actor.name} is immune</div><div><img src=\"${version > 9 ? target.texture.src : target.data.img}\" width=\"30\" height=\"30\" style=\"border:0px\"></div></div>`);\n    } else {\n        let save = await MidiQOL.socket().executeAsGM(\"rollAbility\", { request: \"save\", targetUuid: target.actor.uuid, ability: saveType, options: holysymbolEffect });\n        let rollType = save.options.advantageMode === -1 ? \"Disadvantage\" : save.options.advantageMode === 1 ? \"Advantage\" : \"Normal\";        \n        if (save.total < DC) {\n            if (level_cr >= mon_cr) {\n                console.warn(`=>`, `Target Processed:`, target.actor.name, `| CR:`, mon_cr, `| DC:`, DC, `| Roll:`, rollType, `| Save:`, save.total, `[Fail]`, `| Result: Destroyed`);\n                turnTargets.push(`<div class=\"midi-qol-flex-container\"><div class=\"midi-qol-target-npc midi-qol-target-name\" id=\"${target.id}\">${target.actor.name} fails with ${save.total} [D]</div><div><img src=\"${version > 9 ? target.texture.src : target.data.img}\" width=\"30\" height=\"30\" style=\"border:0px\"></div></div>`);\n                let maxHP = Number(targetData.attributes.hp.max);\n                let updates = version > 9 ? { actor: { \"system.attributes.hp.value\": 0, \"system.attributes.hp.max\": maxHP } } : { actor: { \"data.attributes.hp.value\": 0, \"data.attributes.hp.max\": maxHP } };\n                await warpgate.mutate(target, updates, \"\", { permanent: true });\n            } else {\n                let condition = game.i18n.localize(\"Frightened\");\n                let conditionIcon = \"icons/svg/terror.svg\";\n                let conditionFlags = { \"dae\": { \"token\": target.actor.uuid, specialDuration: [\"isDamaged\"] } };\n                if (((game.modules.get(\"dfreds-convenient-effects\"))) && (game.modules.get(\"dfreds-convenient-effects\")?.active)) {\n                    let dCondition = await game.dfreds.effects[`_${condition.toLowerCase()}`];\n                    if (dCondition) {\n                        conditionIcon = dCondition.icon;\n                        conditionFlags[\"convenientDescription\"] = dCondition.description;\n                        conditionFlags[\"core\"] = { \"statusId\": `Convenient Effect: ${condition}`, \"overlay\": false };\n                        conditionFlags[\"isConvenient\"] = true;\n                    }\n                } else if (((game.modules.get(\"combat-utility-belt\"))) && (game.modules.get(\"combat-utility-belt\")?.active)) {\n                    let cubCondition = game.cub?.conditions?.find(i => i.name === condition);\n                    if (cubCondition) {\n                        conditionIcon = cubCondition.icon;\n                        conditionFlags[\"combat-utility-belt\"] = { \"conditionId\": cubCondition.id, \"overlay\": false };\n                        conditionFlags[\"core\"] = { \"statusId\": `combat-utility-belt.${cubCondition.id}` };\n                    }\n                }\n                console.warn(`=>`, `Target Processed:`, target.actor.name, `| CR:`, mon_cr, `| DC:`, DC, `| Roll:`, rollType, `| Save:`, save.total, `[Fail]`, `| Result: ${condition}`);\n                let effectData = {\n                    label: condition,\n                    icon: conditionIcon,\n                    origin: lastArg.uuid,\n                    disabled: false,\n                    transfer: false,\n                    flags: conditionFlags,\n                    duration: { rounds: 10, startRound: gameRound, startTime: game.time.worldTime },\n                    changes: [{ key: `flags.midi-qol.disadvantage.ability.check.all`, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: 1, priority: 20 },\n                    { key: `flags.midi-qol.disadvantage.skill.all`, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: 1, priority: 20 },\n                    { key: `flags.midi-qol.disadvantage.attack.all`, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: 1, priority: 20 }]\n                };\n                let effect = target.actor.effects.find(i => (version > 9 ? i.label : i.data.label) === condition);\n                if (!effect) {\n                    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: target.actor.uuid, effects: [effectData] });\n                    console.warn(`>`, target.name, `Applyying: ${condition} Condition`, `Success`);\n                } else {\n                    console.error(`>`, target.name, `Applyying: ${condition} Condition`, `Failure`);\n                }\n                turnTargets.push(`<div class=\"midi-qol-flex-container\"><div class=\"midi-qol-target-npc midi-qol-target-name\" id=\"${target.id}\">${target.actor.name} fails with ${save.total} [F]</div><div><img src=\"${version > 9 ? target.texture.src : target.data.img}\" width=\"30\" height=\"30\" style=\"border:0px\"></div></div>`);\n            }\n        } else {\n            console.warn(`=>`, `Target Skipped:`, target.actor.name, `| CR:`, mon_cr, `| DC:`, DC, `| Roll:`, rollType, `| Save:`, save.total, `[Skipped]`, `| Result: Save`);\n            turnTargets.push(`<div class=\"midi-qol-flex-container\"><div class=\"midi-qol-target-npc midi-qol-target-name\" id=\"${target.id}\">${target.actor.name} saves with ${save.total}</div><div><img src=\"${version > 9 ? target.texture.src : target.data.img}\" width=\"30\" height=\"30\" style=\"border:0px\"></div></div>`);\n        }\n    }\n}\n\nconsole.warn(`##### ${itemD.name} Workflow Completed #####`);\n\nawait wait(300);\nlet turn_results = `<div class=\"midi-qol-nobox midi-qol-bigger-text\">${CONFIG.DND5E.abilities[saveType]} Saving Throw: DC ${DC}</div><div><div class=\"midi-qol-nobox\">${turnTargets.join('')}</div></div>`;\nlet chatMessage = await game.messages.get(lastArg.itemCardId);\nlet content = await duplicate((version > 9 ? chatMessage.content : chatMessage.data.content));\nlet searchString = /<div class=\"midi-qol-hits-display\">[\\s\\S]*<div class=\"end-midi-qol-hits-display\">/g;\nlet replaceString = `<div class=\"midi-qol-hits-display\"><div class=\"end-midi-qol-hits-display\">${turn_results}`;\ncontent = await content.replace(searchString, replaceString);\nawait chatMessage.update({ content: content });\nawait ui.chat.scrollBottom();","folder":null,"sort":0,"permission":{"default":0},"flags":{}}},"midi-qol":{"onUseMacroName":"[postActiveEffects]ItemMacro","forceCEOn":false,"effectActivation":false,"forceCEOff":true},"magicitems":{"enabled":false,"equipped":false,"attuned":false,"charges":"0","chargeType":"c1","destroy":false,"destroyFlavorText":"reaches 0 charges: it crumbles into ashes and is destroyed.","rechargeable":false,"recharge":"0","rechargeType":"t1","rechargeUnit":"r1","sorting":"l"},"favtab":{"isFavorite":true},"midiProperties":{"nodam":false,"fulldam":false,"halfdam":false,"rollOther":false,"critOther":false,"magicdam":false,"magiceffect":false,"concentration":false,"toggleEffect":false},"exportSource":{"world":"darklands","system":"dnd5e","coreVersion":"9.280","systemVersion":"1.6.3"},"core":{"sourceId":"Item.1L2MgDcl5nhIxLSs"}},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":1669440918455,"modifiedTime":1669440918455,"lastModifiedBy":"T4cu5jv0VXcrhb1w"},"_id":"1L2MgDcl5nhIxLSs","folder":null,"sort":0,"ownership":{"default":0,"T4cu5jv0VXcrhb1w":3}}
{"name":"Divine Smite","type":"spell","img":"icons/weapons/hammers/hammer-double-glowing-yellow.webp","system":{"description":{"value":"<p>Starting at 2nd level, when you hit a creature with a melee weapon attack, you can expend one spell slot to deal radiant damage to the target, in addition to the weapon’s damage. The extra damage is 2d8 for a 1st-level spell slot, plus 1d8 for each spell level higher than 1st, to a maximum of 5d8. The damage increases by 1d8 if the target is an undead or a fiend, to a maximum of 6d8.</p>","chat":"","unidentified":""},"source":"","activation":{"type":"special","cost":null,"condition":""},"duration":{"value":null,"units":""},"target":{"value":null,"width":null,"units":"","type":""},"range":{"value":5,"long":null,"units":"ft"},"uses":{"value":null,"max":"","per":"","recovery":""},"consume":{"type":"","target":"","amount":null},"ability":"","actionType":"util","attackBonus":0,"chatFlavor":"","critical":{"threshold":null,"damage":null},"damage":{"parts":[["2d8[radiant]","radiant"]],"versatile":""},"formula":"","save":{"ability":"","dc":null,"scaling":"spell"},"level":1,"school":"evo","components":{"value":"","vocal":false,"somatic":true,"material":false,"ritual":false,"concentration":false},"materials":{"value":"","consumed":false,"cost":0,"supply":0},"preparation":{"mode":"always","prepared":true},"scaling":{"mode":"none","formula":""}},"effects":[],"flags":{"midi-qol":{"onUseMacroName":"[preDamageRoll]ItemMacro","forceCEOn":false,"effectActivation":false},"itemacro":{"macro":{"data":{"_id":null,"name":"Divine Smite","type":"script","author":"Tyd5yiqWrRZMvG30","img":"icons/svg/dice-target.svg","scope":"global","command":"// Downloaded from https://www.patreon.com/crymic\n// more macros at https://gitlab.com/crymic/foundry-vtt-macros/\nconst lastArg = args[args.length - 1];\nconst tokenD = canvas.tokens.get(lastArg.tokenId);\nconst actorD = tokenD.actor;\nconst itemD = lastArg.item;\nlet numDice = Math.min(5, Number(lastArg.spellLevel) + 1);\nlet improved = actorD.items.find(i => i.name === \"Improved Divine Smite\");\nif (improved) numDice = numDice += 1;\nlet weapons = actorD.itemTypes.weapon.filter(i=> i.data.data.actionType === \"mwak\").map(i=> i.name);\nlet msgHistory = Object.values(MidiQOL.Workflow.workflows).filter(i => i.actor.id === actorD.id && i.workflowType === \"Workflow\" && weapons.includes(i.item?.name));\nif (msgHistory.length === 0) return ui.notifications.error(`You need to successfully attack first.`);\nlet lastAttack = msgHistory[msgHistory.length - 1];\nlet target = lastAttack.hitTargets.values().next().value;\nlet creatureTypes = [\"undead\", \"fiend\"];\nlet undead = creatureTypes.some(i => (target.actor.data.type === \"character\" ? target.actor.data.data.details.race : target.actor.data.data.details.type.value).toLowerCase().includes(i));\nlet damageType = \"radiant\";\nif (undead) numDice = numDice += 1;\nlet damageRoll = await new game.dnd5e.dice.DamageRoll(`${numDice}d8[${damageType}]`, actorD.getRollData(), { critical: lastAttack.isCritical }).evaluate({ async: true });\nawait game.dice3d?.showForRoll(damageRoll);\nlet damageWorkflow = await new MidiQOL.DamageOnlyWorkflow(actorD, tokenD, damageRoll.total, damageType, [target], damageRoll, { flavor: `(${CONFIG.DND5E.damageTypes[damageType]})`, itemCardId: lastArg.itemCardId, itemData: itemD, useOther: false });\nlet damageBonusMacro = getProperty(actorD.data.flags, `${game.system.id}.DamageBonusMacro`);\nif (damageBonusMacro) {\n    await damageWorkflow.rollBonusDamage(damageBonusMacro);\n} else {\n    await damageWorkflow;\n}\nif ((!(game.modules.get(\"jb2a_patreon\")?.active) && !(game.modules.get(\"sequencer\")?.active))) return {};\nnew Sequence()\n    .effect()\n    .atLocation(target)\n    .file(\"jb2a.divine_smite.target.yellowwhite\")\n    .scaleToObject(2)\n    .play()","folder":null,"sort":0,"permission":{"default":0},"flags":{}},"_id":null,"name":"Divine Smite","type":"script","author":"Tyd5yiqWrRZMvG30","img":"icons/svg/dice-target.svg","scope":"global","command":"// Downloaded from https://www.patreon.com/crymic\n// more macros at https://gitlab.com/crymic/foundry-vtt-macros/\nif (args[0].macroPass === \"preDamageRoll\") {\n    const lastArg = args[args.length - 1];\n    const version = Math.floor(game.version);\n    const actorD = canvas.tokens.get(lastArg.tokenId).actor;\n    const itemUpdate = await fromUuid(lastArg.uuid);\n    let numDice = Math.min(5, Number(lastArg.spellLevel) + 1);\n    let improved = actorD.itemTypes.feat.find(i => i.name === \"Improved Divine Smite\");\n    let improvedAE = actorD.effects.find(i => (version > 9 ? i.label : i.data.label) === \"Improved Divine Smite\");\n    if ((improved) && (!improvedAE)) numDice = numDice += 1;\n    let weapons = actorD.itemTypes.weapon.filter(i => (version > 9 ? i.system.actionType : i.data.data.actionType) === \"mwak\").map(i => i.name);\n    let msgHistory = Object.values(MidiQOL.Workflow.workflows).filter(i => i.actor.id === actorD.id && i.workflowType === \"Workflow\" && weapons.includes(i.item?.name));    \n    if (msgHistory.length === 0) return ui.notifications.error(`You need to successfully attack first.`);\n    let lastAttack = msgHistory[msgHistory.length - 1];\n    let target = lastAttack.hitTargets.values().next().value;\n    let creatureTypes = [\"undead\", \"fiend\"];\n    let undead = creatureTypes.some(i => ((target.actor.getRollData().details?.race) || (target.actor.getRollData().details?.type?.value)).toLowerCase().includes(i));\n    if (undead) numDice = numDice += 1;\n    let damageType = version > 9 ? itemUpdate.system.damage.parts[0][1] : itemUpdate.data.data.damage.parts[0][1];\n    let damageRoll = await new game.dnd5e.dice.DamageRoll(`${numDice}d8[${damageType}]`, actorD.getRollData(), { critical: lastAttack.isCritical }).evaluate({ async: true });\n    if (version > 9) {\n        itemUpdate.system.damage.parts[0][0] = damageRoll.formula;\n    } else {\n        itemUpdate.data.data.damage.parts[0][0] = damageRoll.formula;\n    }\n}","folder":null,"sort":0,"permission":{"default":0},"flags":{}}},"enhanced-terrain-layer":{"multiple":1,"min":0,"max":0,"environment":"","elevation":null,"depth":null},"favtab":{"isFavorite":true},"midiProperties":{"nodam":false,"fulldam":false,"halfdam":false,"rollOther":false,"critOther":false,"magicdam":false,"magiceffect":false,"concentration":false,"toggleEffect":false},"autoanimations":{"version":4,"killAnim":true,"animLevel":false,"options":{"ammo":false},"override":false,"sourceToken":{"enable":false},"targetToken":{"enable":false},"levels3d":{"type":""},"audio":{"a01":{"enable":false}}},"core":{"sourceId":"Item.df19rkjov807oedS"},"exportSource":{"world":"darklands","system":"dnd5e","coreVersion":"9.280","systemVersion":"1.6.3"}},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":1669440918457,"modifiedTime":1669440918457,"lastModifiedBy":"T4cu5jv0VXcrhb1w"},"_id":"3gZCZq4ONyZW7JwM","folder":null,"sort":0,"ownership":{"default":0,"T4cu5jv0VXcrhb1w":3}}
{"name":"Blessed Healer","type":"feat","img":"icons/magic/life/cross-embers-glow-yellow-purple.webp","system":{"description":{"value":"<p>Beginning at 6th level, the healing spells you cast on others heal you as well. When you cast a spell of 1st level or higher that restores hit points to a creature other than you, you regain hit points equal to 2 + the spell's level.</p>","chat":"","unidentified":""},"source":"Life Domain","activation":{"type":"","cost":null,"condition":""},"duration":{"value":null,"units":""},"target":{"value":null,"width":null,"units":"","type":""},"range":{"value":null,"long":null,"units":""},"uses":{"value":0,"max":"0","per":"","recovery":""},"consume":{"type":"","target":"","amount":null},"ability":null,"actionType":"","attackBonus":0,"chatFlavor":"","critical":{"threshold":null,"damage":null},"damage":{"parts":[],"versatile":""},"formula":"","save":{"ability":"","dc":null,"scaling":"spell"},"requirements":"Cleric 6","recharge":{"value":null,"charged":false}},"effects":[{"_id":"dAxNHlflEzzVaSAY","changes":[{"key":"flags.dnd5e.DamageBonusMacro","mode":0,"value":"ItemMacro.Blessed Healer","priority":20}],"disabled":false,"duration":{"startTime":null,"seconds":null,"combat":null,"rounds":null,"turns":null,"startRound":null,"startTurn":null},"icon":"icons/magic/life/cross-embers-glow-yellow-purple.webp","label":"Blessed Healer","transfer":true,"flags":{"dae":{"stackable":"none","macroRepeat":"none","specialDuration":[],"transfer":true},"dnd5e-helpers":{"rest-effect":"Ignore"},"ActiveAuras":{"isAura":false,"aura":"None","radius":null,"alignment":"","type":"","ignoreSelf":false,"height":false,"hidden":false,"hostile":false,"onlyOnce":false}},"tint":null,"origin":null}],"flags":{"core":{"sourceId":"Item.ru7mAcN64DpKgW2u"},"magicitems":{"enabled":false,"equipped":false,"attuned":false,"charges":"0","chargeType":"c1","destroy":false,"destroyFlavorText":"reaches 0 charges: it crumbles into ashes and is destroyed.","rechargeable":false,"recharge":"0","rechargeType":"t1","rechargeUnit":"r1","sorting":"l"},"itemacro":{"macro":{"data":{"_id":null,"name":"Blessed Healer","type":"script","author":"Tyd5yiqWrRZMvG30","img":"icons/svg/dice-target.svg","scope":"global","command":"if(args[0].tag === \"DamageBonus\"){\n    let foundArgs = args[args.length -1];        \n    if (![\"spell\"].includes(foundArgs.item.type)) return {};    \n    if(foundArgs.damageDetail.filter(i=> [\"healing\"].includes(i.type)).length === 0) return {};            \n    if(foundArgs.spellLevel === 0) return {};\n    if(foundArgs.targets.length === 1 && foundArgs.targets[0].id === foundArgs.tokenId) return {};\n    let tokenD = canvas.tokens.get(foundArgs.tokenId);\n    let actorD = tokenD.actor;\n    let itemD = tokenD.actor.items.find(i=> i.name === \"Blessed Healer\")?.data;\n    if(!itemD) return ui.notifications.warn(`Blessed Healer feature is missing on ${tokenD.name}.`);    \n    let spellLevel = Number(foundArgs.spellLevel);\n    console.warn(itemD.name,`Spell Level: ${spellLevel}`,`Total Healing: ${spellLevel + 2}`);\n    let damageType = \"healing\";\n    let damageRoll = new Roll(`${spellLevel + 2}`).evaluate({async:false});\n    new MidiQOL.DamageOnlyWorkflow(actorD, tokenD, damageRoll.total, damageType, [tokenD], damageRoll, { flavor: `(${CONFIG.DND5E.healingTypes[damageType]})`, itemData: itemD, itemCardId: \"new\" });\n}","folder":null,"sort":0,"permission":{"default":0},"flags":{}}}},"exportSource":{"world":"darklands","system":"dnd5e","coreVersion":"9.269","systemVersion":"1.6.2"}},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":1669440918452,"modifiedTime":1669440918452,"lastModifiedBy":"T4cu5jv0VXcrhb1w"},"_id":"6eeFJ0g4PX8aMhHk","folder":null,"sort":0,"ownership":{"default":0,"T4cu5jv0VXcrhb1w":3}}
{"name":"Expert Divination","type":"feat","img":"icons/magic/perception/orb-crystal-ball-scrying-blue.webp","system":{"description":{"value":"<p>Beginning at 6th level, casting divination spells comes so easily to you that it expends only a fraction of your spellcasting efforts. When you cast a divination spell of 2nd level or higher using a spell slot, you regain one expended spell slot. The slot you regain must be of a level lower than the spell you cast and can't be higher than 5th level.</p>","chat":"","unidentified":""},"source":"","activation":{"type":"","cost":0,"condition":""},"duration":{"value":null,"units":""},"target":{"value":null,"width":null,"units":"","type":""},"range":{"value":null,"long":null,"units":""},"uses":{"value":null,"max":"","per":null,"recovery":""},"consume":{"type":"","target":null,"amount":null},"ability":"","actionType":"heal","attackBonus":0,"chatFlavor":"","critical":{"threshold":null,"damage":""},"damage":{"parts":[],"versatile":""},"formula":"","save":{"ability":"","dc":null,"scaling":"spell"},"requirements":"Wizard 6","recharge":{"value":null,"charged":false},"attunement":0},"effects":[{"_id":"kt9jW79qbK1c7oj3","changes":[{"key":"flags.midi-qol.onUseMacroName","mode":0,"value":"ItemMacro.Expert Divination,postActiveEffects","priority":20}],"disabled":false,"duration":{"startTime":null,"seconds":null,"combat":null,"rounds":null,"turns":null,"startRound":null,"startTurn":null},"icon":"icons/magic/perception/orb-crystal-ball-scrying-blue.webp","label":"Expert Divination","transfer":true,"flags":{"core":{"statusId":""},"dae":{"stackable":"none","macroRepeat":"none","specialDuration":[],"transfer":true,"selfTarget":false,"durationExpression":""},"dnd5e-helpers":{"rest-effect":"Ignore"},"ActiveAuras":{"isAura":false,"aura":"None","radius":null,"alignment":"","type":"","ignoreSelf":false,"height":false,"hidden":false,"displayTemp":false,"hostile":false,"onlyOnce":false}},"tint":null,"origin":null}],"flags":{"itemacro":{"macro":{"data":{"_id":null,"name":"Expert Divination","type":"script","author":"Tyd5yiqWrRZMvG30","img":"icons/svg/dice-target.svg","scope":"global","command":"// Midi-qol On Use\nasync function wait(ms) { return new Promise(resolve => { setTimeout(resolve, ms); }); }\nif(args[0].tag === \"DamageBonus\"){\nif(args[0].item.data.level < 2) return {};\nif(args[0].item.data.school != \"div\") return {};\nconst actorD = game.actors.get(args[0].actor._id);\nconst spellSlot = (args[0].spellLevel || args[0].item.data.level)-1;\nconst spellLevel = Math.min(5, spellSlot);\n\nlet inputText = \"\";\nif (hasAvailableSlot(actorD)) {\n    // Get options for available slots\n    for (let i = 1; i <= spellLevel ; i++) {\n        let chosenSpellSlots = getSpellSlots(actorD, i);   \n        let minSlots = chosenSpellSlots.value;\n        let maxSlots = chosenSpellSlots.max;\n        if (minSlots != maxSlots){\n            inputText += `<div class=\"form-group\"><label for=\"spell${i}\">Spell Slot Level ${i} [${minSlots}/${maxSlots}]</label><input id=\"spell${i}\" name=\"spellSlot\" value=\"${i}\" type=\"radio\"></div>`;\n        }\n    }\nnew Dialog({\n        title: \"Expert Divination\",\n        content: `<form><p>Choose 1 spell slot to restore</p><hr>${inputText}</form>`,\n        buttons: {\n            recover: {\n                icon: '<i class=\"fas fa-check\"></i>',\n                label: \"Recover\",\n                callback: async (html) => {\n                let total = html.find('input[type=\"checkbox\"]:checked').length;\n                let selected_slot = html.find('input[name=\"spellSlot\"]:checked');\n                let slot = \"\";\n                let rank = \"\";\n                for(let i = 0; i < selected_slot.length; i++) {\n                slot = selected_slot[i].id;\n                rank = selected_slot[i].value;\n                }\n                console.log(actorD, slot, rank);\n                spell_refund(actorD, slot, rank);\n            }\n        }\n    }\n}).render(true);\n} else {\nawait wait(400);\nlet roll_results = `<div><p style=\"text-align:center\"><b>Expert Divination</b>: No missing spell slots.</p></div>`;\nconst chatMessage = game.messages.get(args[0].itemCardId);\nlet content = duplicate(chatMessage.data.content);\nconsole.log(content);\nconst searchString =  /<div class=\"midi-qol-bonus-roll\">[\\s\\S]*<div class=\"end-midi-qol-bonus-roll\">/g;\nconst replaceString = `<div class=\"midi-qol-bonus-roll\"><div class=\"end-midi-qol-bonus-roll\">${roll_results}`;\ncontent = content.replace(searchString, replaceString);\nchatMessage.update({content: content});\n    }\n}\nasync function spell_refund(actorD, slot, rank) {    \n    let actor_data = duplicate(actorD.data);    \n    actor_data.data.spells[`${slot}`].value = actor_data.data.spells[`${slot}`].value + 1;\n    await actorD.update(actor_data);\n    await wait(400);\n    let roll_results = `<div><p style=\"text-align:center\"><b>Expert Divination</b>: Restored level ${rank} spell slot.</p></div>`;\n    const chatMessage = game.messages.get(args[0].itemCardId);\n    let content = duplicate(chatMessage.data.content);\n    const searchString =  /<div class=\"midi-qol-bonus-roll\">[\\s\\S]*<div class=\"end-midi-qol-bonus-roll\">/g;\n    const replaceString = `<div class=\"midi-qol-bonus-roll\"><div class=\"end-midi-qol-bonus-roll\">${roll_results}`;\n    content = content.replace(searchString, replaceString);\n    chatMessage.update({content: content});\n}\n\t\nfunction getSpellSlots(actorD, level) {\n    return actorD.data.data.spells[`spell${level}`];\n}\n\nfunction hasAvailableSlot(actorD) {\n    for (let slot in actorD.data.data.spells) {\n        if (actorD.data.data.spells[slot].value < actorD.data.data.spells[slot].max) {\n            return true;\n        }\n    }\n    return false;\n}","folder":null,"sort":0,"permission":{"default":0},"flags":{}},"_id":null,"name":"Expert Divination","type":"script","author":"Tyd5yiqWrRZMvG30","img":"icons/svg/dice-target.svg","scope":"global","command":"// Midi-qol On Use\nasync function wait(ms) { return new Promise(resolve => { setTimeout(resolve, ms); }); }\nif (args[0].macroPass === \"postActiveEffects\") {\n    const lastArg = args[args.length - 1];\n    const version = Math.floor(game.version);\n    if ((version > 9 ? lastArg.item.system.level : lastArg.item.data.level) < 2) return {};\n    if ((version > 9 ? lastArg.item.system.school : lastArg.item.data.school) != \"div\") return {};\n    const tokenD = canvas.tokens.get(lastArg.tokenId);\n    const actorD = tokenD.actor;\n    const actorData = await actorD.getRollData();\n    const spellLevel = Number(lastArg.spellLevel);\n\n    const spellList = Object.keys(actorData.spells).reduce((acc, values, i) => {\n        if ((!(i < 2)) && (!(i > 5)) && (!(i >= spellLevel)) && (actorData.spells[`spell${i}`].value != actorData.spells[`spell${i}`].max)) acc.push(`<div class=\"form-group\"><label for=\"spell${i}\">Spell Slot Level ${i} [${actorData.spells[`spell${i}`].value}/${actorData.spells[`spell${i}`].max}]</label><input id=\"spell${i}\" name=\"spellSlot\" value=\"${i}\" type=\"radio\"></div>`);\n        else return acc;\n        return acc;\n    }, []);\n    if (spellList.length === 0) return ui.notifications.error(`${actorD.name} is not missing any spell slots`);\n\n    let slotValue = await new Promise((resolve) => {\n        new Dialog({\n            title: `Expert Divination`,\n            content: `<form><p>Choose 1 spell slot to restore</p><hr>${spellList.join('')}</form>`,\n            buttons: {\n                recover: {\n                    icon: '<i class=\"fas fa-check\"></i>',\n                    label: \"Recover\",\n                    callback: async (html) => {\n                        let num = await html.find('input[name=\"spellSlot\"]:checked')[0].value;\n                        resolve(`spell${num}`);\n                        let roll_results = `<div>Expert Divination: Regains 1 spell slot, Level ${num}.</div>`;\n                        let chatMessage = game.messages.get(lastArg.itemCardId);\n                        let content = duplicate((version > 9 ? chatMessage.content : chatMessage.data.content));\n                        let searchString = /<div class=\"midi-qol-bonus-roll\">[\\s\\S]*<div class=\"end-midi-qol-bonus-roll\">/g;\n                        let replaceString = `<div class=\"midi-qol-bonus-roll\"><div class=\"end-midi-qol-bonus-roll\">${roll_results}`;\n                        content = content.replace(searchString, replaceString);\n                        await chatMessage.update({ content: content });\n                    }\n                }\n            },\n            default: \"Recover\"\n        }).render(true);\n    });\n\n    if (!slotValue) return {};\n    let updates = {};\n    let resources = version > 9 ? `system.spells.${slotValue}.value` : `data.spells.${slotValue}.value`;\n    let spellNum = actorData.spells[`${slotValue}`].value + 1;\n    updates[resources] = spellNum;\n    await actorD.update(updates);\n}","folder":null,"sort":0,"permission":{"default":0},"flags":{}}},"magicitems":{"enabled":false,"equipped":false,"attuned":false,"charges":"0","chargeType":"c1","destroy":false,"destroyFlavorText":"reaches 0 charges: it crumbles into ashes and is destroyed.","rechargeable":false,"recharge":"0","rechargeType":"t1","rechargeUnit":"r1","sorting":"l"},"core":{"sourceId":"Item.3l8pJigvL0jWIUfF"},"midi-qol":{"effectActivation":false,"onUseMacroName":"[postActiveEffects]"},"midiProperties":{"nodam":false,"fulldam":false,"halfdam":false,"rollOther":false,"critOther":false,"magicdam":false,"magiceffect":false,"concentration":false,"toggleEffect":false},"exportSource":{"world":"darklands","system":"dnd5e","coreVersion":"9.280","systemVersion":"1.6.3"}},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":1669440918459,"modifiedTime":1669440918459,"lastModifiedBy":"T4cu5jv0VXcrhb1w"},"_id":"7lj3V70KFJWNNz5g","folder":null,"sort":0,"ownership":{"default":0,"T4cu5jv0VXcrhb1w":3}}
{"name":"Unarmed Strike","type":"weapon","img":"icons/equipment/hand/gauntlet-simple-leather-brown-gold.webp","system":{"description":{"value":"<p><em><strong></strong> Melee Weapon Attack:</em> +9 to hit, reach 5 ft., one creature. <em>Hit:</em> 8 (1d8 + 4) bludgeoning damage. Instead of dealing damage, the vampire can grapple the target (escape DC 18).</p>","chat":"","unidentified":""},"source":"Basic Rules pg 352","quantity":1,"weight":0,"price":0,"attunement":0,"equipped":true,"rarity":"","identified":true,"activation":{"type":"action","cost":1,"condition":""},"duration":{"value":null,"units":""},"target":{"value":null,"width":null,"units":"","type":""},"range":{"value":5,"long":null,"units":"ft"},"uses":{"value":0,"max":"0","per":"","recovery":""},"consume":{"type":"","target":"","amount":null},"ability":"str","actionType":"mwak","attackBonus":"0","chatFlavor":"","critical":{"threshold":null,"damage":""},"damage":{"parts":[],"versatile":""},"formula":"","save":{"ability":"","dc":null,"scaling":"spell"},"armor":{"value":10},"hp":{"value":0,"max":0,"dt":null,"conditions":""},"weaponType":"simpleM","baseItem":"","properties":{"amm":false,"fin":false,"fir":false,"foc":false,"hvy":false,"lgt":false,"lod":false,"rch":false,"rel":false,"ret":false,"spc":false,"thr":false,"two":false,"ver":false,"ada":false,"mgc":false,"sil":false,"nodam":false,"fulldam":false,"halfdam":false,"critOther":false},"proficient":true,"recharge":{"value":null,"charged":null}},"effects":[],"flags":{"monsterMunch":{"titleHTML":"<strong>Unarmed Strike (Vampire Form Only).</strong>","fullName":"Unarmed Strike (Vampire Form Only)."},"midi-qol":{"criticalThreshold":"20","onUseMacroName":"[postActiveEffects]ItemMacro","effectActivation":false,"fumbleThreshold":null},"magicitems":{"enabled":false,"equipped":false,"attuned":false,"charges":"0","chargeType":"c1","destroy":false,"destroyFlavorText":"reaches 0 charges: it crumbles into ashes and is destroyed.","rechargeable":false,"recharge":"0","rechargeType":"t1","rechargeUnit":"r1","sorting":"l"},"itemacro":{"macro":{"data":{"_id":null,"name":"Unarmed Strike","type":"script","author":"Tyd5yiqWrRZMvG30","img":"icons/svg/dice-target.svg","scope":"global","command":"async function wait(ms) { return new Promise(resolve => { setTimeout(resolve, ms); }); }\nconst lastArg = args[args.length - 1];\nif (lastArg.hitTargets.length === 0) return {};\nconst actorD = game.actors.get(lastArg.actor._id);\nconst tokenD = canvas.tokens.get(lastArg.tokenId);\nconst target = canvas.tokens.get(lastArg.hitTargets[0].id);\nconst itemD = lastArg.item;\nconst damageType = \"bludgeoning\";\nconst baseNum = lastArg.isCritical ? 2 : 1;\nconst damageRoll = new Roll(`${baseNum}d8 + @abilities.str.mod`, tokenD.actor.getRollData()).evaluate({ async: false });\nconst effect = target.actor.effects.find(i => i.data.label === game.i18n.localize(\"Grappled\"));\nif (!effect) {\n    new Dialog({\n        title: itemD.name,\n        content: `Pick an attack`,\n        buttons: {\n            attack: {\n                label: \"Attack\", callback: async () => {\n                    game.dice3d?.showForRoll(damageRoll);\n                    await new MidiQOL.DamageOnlyWorkflow(actorD, tokenD, damageRoll.total, damageType, [target], damageRoll, { flavor: `(${CONFIG.DND5E.damageTypes[damageType]})`, itemCardId: lastArg.itemCardId, useOther: false });\n                }\n            },\n            grapple: {\n                label: \"Grappled\", callback: async () => {\n                    let saveType = \"dex\";\n                    let DC = 18;\n                    let save = await MidiQOL.socket().executeAsGM(\"rollAbility\", { request: \"save\", targetUuid: target.actor.uuid, ability: saveType, options: { chatMessage: false, fastForward: true } });\n                    let success = \"saves\";\n                    if (save.total < DC) {\n                        success = \"fails\";\n                        let gameRound = game.combat ? game.combat.round : 0;\n                        let effectData = {\n                            label: \"Grappled\",\n                            icon: \"modules/combat-utility-belt/icons/grappled.svg\",\n                            origin: lastArg.uuid,\n                            disabled: false,\n                            duration: { rounds: 10, seconds: 60, startRound: gameRound, startTime: game.time.worldTime },\n                            changes: [{ key: `data.attributes.movement.all`, mode: 5, value: 0, priority: 20 }]\n                        };\n                        await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: target.actor.uuid, effects: [effectData] });\n                    }\n                    await wait(300);\n                    let grapple_msg = `<div class=\"midi-qol-flex-container\"><div class=\"midi-qol-target-npc midi-qol-target-name\" id=\"${target.id}\">${target.name} ${success} with ${save.total}</div><div><img src=\"${target.data.img}\" width=\"30\" height=\"30\" style=\"border:0px\"></div></div>`;\n                    let grapple_result = `<div class=\"midi-qol-nobox midi-qol-bigger-text\">${CONFIG.DND5E.abilities[saveType]} Saving Throw: DC ${DC}</div><div><div class=\"midi-qol-nobox\">${grapple_msg}</div></div>`;\n                    let chatMessage = await game.messages.get(lastArg.itemCardId);\n                    let content = await duplicate(chatMessage.data.content);\n                    let searchString = /<div class=\"midi-qol-hits-display\">[\\s\\S]*<div class=\"end-midi-qol-hits-display\">/g;\n                    let replaceString = `<div class=\"midi-qol-hits-display\"><div class=\"end-midi-qol-hits-display\">${grapple_result}`;\n                    content = await content.replace(searchString, replaceString);\n                    await chatMessage.update({ content: content });\n                    await ui.chat.scrollBottom();\n                }\n            }\n        },\n        default: \"attack\"\n    }).render(true);\n} else {\n    game.dice3d?.showForRoll(damageRoll);\n    await new MidiQOL.DamageOnlyWorkflow(actorD, tokenD, damageRoll.total, damageType, [target], damageRoll, { flavor: `(${CONFIG.DND5E.damageTypes[damageType]})`, itemCardId: lastArg.itemCardId, useOther: false });\n}","folder":null,"sort":0,"permission":{"default":0},"flags":{}}}},"favtab":{"isFavorite":true},"core":{"sourceId":"Item.WCPuzIrBzJ8pczQT"},"exportSource":{"world":"darklands","system":"dnd5e","coreVersion":"0.8.9","systemVersion":"1.5.5"},"midiProperties":{"nodam":false,"fulldam":false,"halfdam":false,"rollOther":false,"critOther":false,"magicdam":false,"magiceffect":false,"concentration":false,"toggleEffect":false}},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":1669440918466,"modifiedTime":1669440918466,"lastModifiedBy":"T4cu5jv0VXcrhb1w"},"_id":"Arcl87UndZ5llLBp","folder":null,"sort":0,"ownership":{"default":0,"T4cu5jv0VXcrhb1w":3}}
{"name":"Channel Divinity: Twilight Sanctuary","type":"feat","img":"icons/magic/unholy/orb-glowing-purple.webp","system":{"description":{"value":"<p>At 2nd level, you can use your Channel Divinity to refresh your allies with soothing twilight.</p>\n<p>As an action, you present your holy symbol, and a sphere of twilight emanates from you. The sphere is centered on you, has a 30-foot radius, and is filled with dim light. The sphere moves with you, and it lasts for 1 minute or until you are incapacitated or die. Whenever a creature (including you) ends its turn in the sphere, you can grant that creature one of these benefits:</p>\n<ul>\n<li>You grant it temporary hit points equal to 1d6 plus your cleric level.</li>\n</ul>\n<ul>\n<li>You end one effect on it causing it to be charmed or frightened.</li>\n</ul>","chat":"","unidentified":""},"source":"","activation":{"type":"action","cost":1,"condition":""},"duration":{"value":1,"units":"minute"},"target":{"value":null,"width":null,"units":"","type":"self"},"range":{"value":null,"long":null,"units":"self"},"uses":{"value":null,"max":"","per":"","recovery":""},"consume":{"type":"","target":"","amount":null},"ability":null,"actionType":"","attackBonus":0,"chatFlavor":"","critical":{"threshold":null,"damage":null},"damage":{"parts":[],"versatile":""},"formula":"","save":{"ability":"","dc":null,"scaling":"spell"},"requirements":"Cleric 2","recharge":{"value":null,"charged":false},"attunement":0},"effects":[{"_id":"1hqx1DYQOHgMTize","changes":[{"key":"macro.itemMacro","mode":0,"value":"","priority":20}],"disabled":false,"duration":{"startTime":null,"seconds":null,"combat":null,"rounds":null,"turns":null,"startRound":null,"startTurn":null},"icon":"icons/magic/unholy/orb-glowing-purple.webp","label":"Channel Divinity: Twilight Sanctuary","transfer":false,"flags":{"dae":{"stackable":"none","macroRepeat":"none","specialDuration":[],"transfer":false},"ActiveAuras":{"isAura":false,"aura":"None","radius":null,"alignment":"","type":"","ignoreSelf":false,"height":false,"hidden":false,"hostile":false,"onlyOnce":false},"core":{"statusId":""},"dnd5e-helpers":{"rest-effect":"Ignore"}},"tint":null,"origin":null}],"flags":{"magicitems":{"enabled":false,"equipped":false,"attuned":false,"charges":"0","chargeType":"c1","destroy":false,"destroyFlavorText":"reaches 0 charges: it crumbles into ashes and is destroyed.","rechargeable":false,"recharge":"0","rechargeType":"t1","rechargeUnit":"r1","sorting":"l"},"itemacro":{"macro":{"data":{"_id":null,"name":"Channel Divinity: Twilight Sanctuary","type":"script","author":"Tyd5yiqWrRZMvG30","img":"icons/svg/dice-target.svg","scope":"global","command":"async function wait(ms) { return new Promise(resolve => { setTimeout(resolve, ms); }); }\nconst lastArg = args[args.length - 1];\nconst tokenD = canvas.tokens.get(lastArg.tokenId);\nconst originItem = lastArg.efData.flags.dae.itemData;\nconst originEffectId = lastArg.effectId;\nconsole.log(lastArg);\n\nasync function combatRound(combat, update) {\n  if (!(\"round\" in update || \"turn\" in update)) return;\n  return new Promise(async (resolve) => {\n    let item = tokenD.actor.data.items.find(i => i.name === \"Soothing Twilight\");\n    if(!item) {\n      let effect = tokenD.actor.effects.find(i=> i.data.label === originItem.name);\n      await MidiQOL.socket().executeAsGM(\"removeEffects\", { actorUuid: tokenD.actor.uuid, effects: [effect.id] });\n      return ui.notifications.warn(`Shutting Down ${originItem.name}, Soothing Twilight is missing.`);\n    };\n    let distance = item.data.data.range.value;\n    let target = canvas.tokens.get(game.combat.previous.tokenId);\n    let targetDis = target.data.disposition + 1;\n    let targetDistance = MidiQOL.getDistance(tokenD, target, true, true);\n    let friendly = targetDistance <= distance && tokenD.data.disposition === target.data.disposition;\n    let matchDis = Object.keys(CONST.TOKEN_DISPOSITIONS)[targetDis];\n    if (!friendly) return console.log(`${item.name} skipping target ${target.name} => [${matchDis}]`);\n    await target.setTarget(true, { releaseOthers: true });\n    await item.roll();\n  });\n}\n\nif (args[0] === \"on\") {\n  let hookId = Hooks.on(\"updateCombat\", combatRound);\n  DAE.setFlag(tokenD.actor, \"twilightEffect\", hookId);\n  let itemData = [{\n    \"name\": \"Soothing Twilight\",\n    \"type\": \"feat\",\n    \"img\": \"icons/magic/unholy/barrier-shield-glowing-pink.webp\",\n    \"data\": {\n      \"description\": {\n        \"value\": \"<p>Whenever a creature (including you) ends its turn in the sphere, you can grant that creature one of these benefits:</p>\\n<ul>\\n<li>You grant it temporary hit points equal to 1d6 plus your cleric level.</li>\\n</ul>\\n<ul>\\n<li>You end one effect on it causing it to be charmed or frightened.</li>\\n</ul>\",\n        \"chat\": \"\",\n        \"unidentified\": \"\"\n      },\n      \"activation\": {\n        \"type\": \"special\",\n        \"cost\": null,\n        \"condition\": \"\"\n      },\n      \"range\": {\n        \"value\": 30,\n        \"long\": null,\n        \"units\": \"ft\"\n      }\n    },\n    \"flags\": {\n      \"midi-qol\": {\n        \"onUseMacroName\": \"ItemMacro\"\n      },\n      \"itemacro\": {\n        \"autoanimations\": {\n          \"version\": 2,\n          \"killAnim\": false,\n          \"animLevel\": false,\n          \"options\": {\n            \"ammo\": false,\n            \"staticType\": \"target\",\n            \"opacity\": 1,\n            \"persistent\": false,\n            \"staticOptions\": \"staticSpells\",\n            \"variant\": \"02\",\n            \"repeat\": 1,\n            \"delay\": 250,\n            \"scale\": 1,\n            \"enableCustom\": false\n          },\n          \"override\": true,\n          \"sourceToken\": {\n            \"enable\": false\n          },\n          \"targetToken\": {\n            \"enable\": false\n          },\n          \"animType\": \"static\",\n          \"animation\": \"generichealing\",\n          \"color\": \"purplepink\",\n          \"audio\": {\n            \"a01\": {\n              \"enable\": false\n            }\n          },\n          \"explosions\": {\n            \"enable\": false\n          }\n        },\n        \"macro\": {\n          \"data\": {\n            \"_id\": null,\n            \"name\": \"Soothing Twilight\",\n            \"type\": \"script\",\n            \"author\": \"Tyd5yiqWrRZMvG30\",\n            \"img\": \"icons/svg/dice-target.svg\",\n            \"scope\": \"global\",\n            \"command\": \"async function wait(ms) { return new Promise(resolve => { setTimeout(resolve, ms); }); }\\nconst actorD = game.actors.get(args[0].actor._id);\\nconst tokenD = canvas.tokens.get(args[0].tokenId);\\nconst itemD = args[0].item;\\nconst target = canvas.tokens.get(args[0].targets[0].id);\\nconst cancel = false;\\nlet aButtons = { cancel: { label: \\\"Cancel\\\", callback: async () => cancel } };\\nlet heal = \\\"heal\\\";\\nlet cure = \\\"cure\\\";\\nlet targetTempHp = target.actor.data.data.attributes.hp.temp;\\nlet maxPosTemp = await new Roll('1d6 + @classes.cleric.levels', actorD.getRollData()).evaluate({ maximize: true, async: true }).total;\\nlet damageRoll = await new Roll('1d6 + @classes.cleric.levels', actorD.getRollData()).evaluate({ async: true });\\nconsole.log(`[${itemD.name}] Maximum Temp Heal: ${damageRoll.formula} = ${maxPosTemp}`);\\nconsole.log(`Target: ${target.name}, Current TempHP: ${targetTempHp != null ? targetTempHp : 0}, Rolled TempHp: ${damageRoll.total} => ${damageRoll.total > targetTempHp ? \\\"Continue\\\" : \\\"Terminated\\\"}`);\\nlet target_conditions = [\\\"Charmed\\\", \\\"Frightened\\\"];\\nlet targetInflicted = target.actor.effects.filter(i => target_conditions.includes(i.data.label)).reduce((list, item) => {\\n    console.log(`Condition Found: ${item.data.label}`);\\n    list.push(`<img class=\\\"condition\\\" src=\\\"${item.data.icon}\\\" width=\\\"30\\\" height=\\\"30\\\" title=\\\"${item.data.label}\\\"}>`);\\n    return list;\\n}, []);\\n\\nif ((targetTempHp === maxPosTemp) && (targetInflicted.length === 0)) return await game.user.updateTokenTargets([]);\\n\\nif ((targetTempHp != maxPosTemp) && (damageRoll.total > targetTempHp)) {\\n    aButtons[heal] = {\\n        label: \\\"Heal\\\", callback: async (html) => {\\n            let damageType = \\\"temphp\\\";\\n            game.dice3d?.showForRoll(damageRoll);\\n            await new MidiQOL.DamageOnlyWorkflow(actorD, tokenD, damageRoll.total, damageType, [target], damageRoll, { flavor: `(${CONFIG.DND5E.healingTypes[damageType]})`, itemCardId: args[0].itemCardId, useOther: false });\\n            await ui.chat.scrollBottom();            \\n            await game.user.updateTokenTargets([]);\\n        }\\n    }\\n}\\n\\nif (targetInflicted.length > 0) {\\n    aButtons[cure] = {\\n        label: \\\"Cure\\\", callback: async () => {\\n            let condition_list = [\\\"Charmed\\\", \\\"Frightened\\\"];\\n            let effect = target.actor.effects.filter(i => condition_list.includes(i.data.label));\\n            let selectOptions = \\\"\\\";\\n            for (let i = 0; i < effect.length; i++) {\\n                let condition = effect[i].data.label;\\n                selectOptions += `<option value=\\\"${condition}\\\">${condition}</option>`;\\n            }\\n            if (selectOptions === \\\"\\\") {\\n                return ui.notifications.warn(`There's nothing to Cure on ${target.name}.`);\\n            } else {\\n                let content_cure = `<p>Choose a Condition Cure</p><form class=\\\"flexcol\\\"><div class=\\\"form-group\\\"><select id=\\\"element\\\">${selectOptions}</select></div></form>`;\\n                new Dialog({\\n                    title: itemD.name,\\n                    content: content_cure,\\n                    buttons: {\\n                        cure: {\\n                            icon: '<i class=\\\"fas fa-check\\\"></i>',\\n                            label: 'Cure!',\\n                            callback: async (html) => {\\n                                let element = html.find('#element').val();\\n                                let effect = target.actor.effects.find(i => i.data.label === element);\\n                                if (effect) await MidiQOL.socket().executeAsGM(\\\"removeEffects\\\", { actorUuid: target.actor.uuid, effects: [effect.id] });\\n                                let chatContent = `<div class=\\\"midi-qol-nobox\\\"><div class=\\\"midi-qol-flex-container\\\"><div>Cures ${element}:</div><div class=\\\"midi-qol-target-npc midi-qol-target-name\\\" id=\\\"${target.id}\\\"> ${target.name}</div><div><img src=\\\"${target.data.img}\\\" width=\\\"30\\\" height=\\\"30\\\" style=\\\"border:0px\\\"></img></div></div></div>`;\\n                                await wait(500);\\n                                const chatMessage = game.messages.get(args[0].itemCardId);\\n                                let content = duplicate(chatMessage.data.content);\\n                                const searchString = /<div class=\\\"midi-qol-hits-display\\\">[\\\\s\\\\S]*<div class=\\\"end-midi-qol-hits-display\\\">/g;\\n                                const replaceString = `<div class=\\\"midi-qol-hits-display\\\"><div class=\\\"end-midi-qol-hits-display\\\">${chatContent}`;\\n                                content = content.replace(searchString, replaceString);\\n                                chatMessage.update({ content: content });\\n                                await ui.chat.scrollBottom();                                \\n                                await game.user.updateTokenTargets([]);\\n                            }\\n                        }\\n                    },\\n                    default: \\\"cure\\\",\\n                }).render(true);\\n            }\\n        }\\n    }\\n}\\nlet finalButtons = Object.values(aButtons);\\nif (finalButtons.length === 1) return await game.user.updateTokenTargets([]);\\nnew Dialog({\\n    title: `${itemD.name} : Choose an Effect`,\\n    content: `<style>#twilightInfo img{border:none}#twilightInfo{padding:10px}#twilightInfo .target{margin-right:10px}#twilightInfo .condition{border:1px solid red!important;margin:2px 5px}#twilightInfo ul{list-style:none}#twilightInfo ul li{float:left;margin-right:5px}</style><div id=\\\"twilightInfo\\\" class=\\\"form-group\\\"><ul><li><img class=\\\"target\\\" src=\\\"${target.data.img}\\\" height=\\\"40\\\" width=\\\"40\\\" title=\\\"${target.name}\\\"></li><li><div><b>Target:</b> ${target.name}</div><div><b>Temp HP:</b> ${targetTempHp != null ? targetTempHp : 0} / ${maxPosTemp}</div></li><li><div>${targetInflicted.join('')}</div></li></ul></div>`,\\n    buttons: aButtons,\\n    default: cancel\\n}).render(true);\",\n            \"folder\": null,\n            \"sort\": 0,\n            \"permission\": {\n              \"default\": 0\n            },\n            \"flags\": {}\n          }\n        },\n        \"autoanimations\": {\n          \"version\": 2,\n          \"killAnim\": false,\n          \"animLevel\": false,\n          \"options\": {\n            \"ammo\": false,\n            \"staticType\": \"target\",\n            \"opacity\": 1,\n            \"persistent\": false,\n            \"staticOptions\": \"staticSpells\",\n            \"variant\": \"02\",\n            \"repeat\": 1,\n            \"delay\": 250,\n            \"scale\": 1,\n            \"enableCustom\": false\n          },\n          \"override\": true,\n          \"sourceToken\": {\n            \"enable\": false\n          },\n          \"targetToken\": {\n            \"enable\": false\n          },\n          \"animType\": \"static\",\n          \"animation\": \"generichealing\",\n          \"color\": \"purplepink\",\n          \"audio\": {\n            \"a01\": {\n              \"enable\": false\n            }\n          },\n          \"explosions\": {\n            \"enable\": false\n          }\n        }\n      }\n    }\n  }];\n  let item = tokenD.actor.items.find(i => i.name === \"Soothing Twilight\");\n  if (item) {\n    await tokenD.actor.deleteEmbeddedDocuments(\"Item\", [item.id]);\n    await tokenD.actor.createEmbeddedDocuments(\"Item\", itemData);\n  } else {\n    await tokenD.actor.createEmbeddedDocuments(\"Item\", itemData);\n  }\n}\n\nif (args[0] === \"off\") {\n  let item = tokenD.actor.items.find(i => i.name === \"Soothing Twilight\");\n  let hookId = DAE.getFlag(tokenD.actor, \"twilightEffect\");\n  Hooks.off(\"updateCombat\", hookId);\n  await DAE.unsetFlag(tokenD.actor, \"twilightEffect\");\n  if (item) await tokenD.actor.deleteEmbeddedDocuments(\"Item\", [item.id]);\n}","folder":null,"sort":0,"permission":{"default":0},"flags":{}},"_id":null,"name":"Channel Divinity: Twilight Sanctuary","type":"script","author":"Tyd5yiqWrRZMvG30","img":"icons/svg/dice-target.svg","scope":"global","command":"async function wait(ms) { return new Promise(resolve => { setTimeout(resolve, ms); }); }\nconst lastArg = args[args.length - 1];\nconst version = Math.floor(game.version);\nlet tactor;\nif (lastArg.tokenId) tactor = canvas.tokens.get(lastArg.tokenId).actor;\nelse tactor = game.actors.get(lastArg.actorId);\nconst tokenD = canvas.tokens.get(lastArg.tokenId);\nconst originItem = duplicate(lastArg.efData.flags.dae.itemData);\nconst originEffectId = lastArg.effectId;\n\nasync function combatRound(combat, update) {\n  if (!(\"round\" in update || \"turn\" in update)) return;\n  if (!game.combat) {\n    let effect = tactor.effects.find(i => (version > 9 ? i.label : i.data.label) === originItem.name);\n    if (effect) await MidiQOL.socket().executeAsGM(\"removeEffects\", { actorUuid: tactor.uuid, effects: [effect.id] });\n    return ui.notifications.warn(`Not in Combnat ${originItem.name}, Shutting Down`);\n  }\n  if (tactor.effects.find(i => (version > 9 ? i.label : i.data.label) === \"Incapacitated\")) {\n    let effect = tactor.effects.find(i => (version > 9 ? i.label : i.data.label) === originItem.name);\n    await MidiQOL.socket().executeAsGM(\"removeEffects\", { actorUuid: tactor.uuid, effects: [effect.id] });\n    return ui.notifications.warn(`Not in Combnat ${originItem.name}, Shutting Down`);\n  }\n  return new Promise(async (resolve) => {\n    let item = tactor.itemTypes.feat.find(i => i.name === \"Soothing Twilight\");\n    if (!item) {\n      let effect = tactor.effects.find(i => (version > 9 ? i.label : i.data.label) === originItem.name);\n      await MidiQOL.socket().executeAsGM(\"removeEffects\", { actorUuid: tactor.uuid, effects: [effect.id] });\n      return ui.notifications.warn(`Shutting Down ${originItem.name}, Soothing Twilight is missing.`);\n    };\n    let itemData = await item.getChatData();\n    let distance = itemData.range.value;\n    let target = canvas.tokens.get(game.combat.previous.tokenId);\n    let targetDis = (version > 9 ? target.document.disposition : target.document.data.disposition) + 1;\n    let targetDistance = await MidiQOL.getDistance(tokenD, target, true, true);\n    let friendly = targetDistance <= distance && ((version > 9 ? tokenD.document.disposition : tokenD.document.data.disposition) === (version > 9 ? target.document.disposition : target.document.data.disposition));\n    let matchDis = Object.keys(CONST.TOKEN_DISPOSITIONS)[targetDis];\n    if (!friendly) return console.error(`${item.name} skipping target ${target.name} => [${matchDis}]`);\n    await target.setTarget(true, { releaseOthers: true });\n    let itemRoll = version > 9 ? await item.use() : await item.roll();\n    resolve(itemRoll);\n  });\n}\n\nif (args[0] === \"on\") {\n  if (!game.combat) {\n    let effect = tactor.effects.find(i => (version > 9 ? i.label : i.data.label) === originItem.name);\n    await MidiQOL.socket().executeAsGM(\"removeEffects\", { actorUuid: tactor.uuid, effects: [effect.id] });\n    return ui.notifications.error(`You're not in combat, shutting down ${originItem.name}`);\n  }\n  console.group(`Twilight Sanctuary => Starting`);\n  let currentId = await DAE.getFlag(tactor, \"twilightEffect\");\n  if (currentId) {\n    console.warn(`Twilight Sanctuary`, `Deleting`, `Hooks`);\n    Hooks.off(\"updateCombat\", currentId);\n    await DAE.unsetFlag(tactor, \"twilightEffect\");\n  }\n  console.warn(`Twilight Sanctuary`, `Creating`, `Hooks`);\n  let hookId = Hooks.on(\"updateCombat\", combatRound);\n  await DAE.setFlag(tactor, \"twilightEffect\", hookId);\n  let itemData = {\n    \"name\": \"Soothing Twilight\",\n    \"type\": \"feat\",\n    \"img\": \"icons/magic/unholy/barrier-shield-glowing-pink.webp\",    \n    \"flags\": {\n      \"itemCreated\": {\n        \"actorId\": tactor.id\n      },\n      \"midi-qol\": {\n        \"onUseMacroName\": \"[postActiveEffects]ItemMacro\",\n        \"effectActivation\": false\n      },\n      \"itemacro\": {\n        \"macro\": {\n          \"_id\": null,\n          \"name\": \"Soothing Twilight\",\n          \"type\": \"script\",\n          \"author\": \"Tyd5yiqWrRZMvG30\",\n          \"img\": \"icons/svg/dice-target.svg\",\n          \"scope\": \"global\",\n          \"command\": \"async function wait(ms) { return new Promise(resolve => { setTimeout(resolve, ms); }); }\\nconst lastArg = args[args.length - 1];\\nconst tokenD = canvas.tokens.get(lastArg.tokenId);\\nconst actorD = tokenD.actor;\\nconst itemD = lastArg.item;\\nconst target = canvas.tokens.get(lastArg.targets[0].id);\\nconst version = Math.floor(game.version);\\nconst cancel = false;\\nconst damageType = \\\"temphp\\\";\\nlet aButtons = { cancel: { label: \\\"Cancel\\\", icon: `<img src=\\\"icons/anvil.png\\\" width=\\\"30\\\" height=\\\"30\\\">`, callback: async () => cancel } };\\nlet heal = \\\"heal\\\";\\nlet cure = \\\"cure\\\";\\nlet targetTempHp = target.actor.getRollData().attributes.hp.temp;\\nlet maxPosTemp = await new Roll('1d6[temphp] + @classes.cleric.levels', actorD.getRollData()).evaluate({ maximize: true, async: true }).total;\\nlet damageRoll = await new Roll('1d6[temphp] + @classes.cleric.levels', actorD.getRollData()).evaluate({ async: true });\\nconsole.log(`[${itemD.name}] Maximum Temp Heal: ${damageRoll.formula} = ${maxPosTemp}`);\\nconsole.log(`Target: ${target.name}, Current TempHP: ${targetTempHp != null ? targetTempHp : 0}, Rolled TempHp: ${damageRoll.total} => ${damageRoll.total > targetTempHp ? \\\"Continue\\\" : \\\"Terminated\\\"}`);\\nlet target_conditions = [\\\"Charmed\\\", \\\"Frightened\\\"];\\nlet targetInflicted = target.actor.effects.filter(i => target_conditions.includes(\\n    (version > 9 ? i.label : i.data.label))).reduce((list, item) => {\\n        console.log(`Condition Found: ${(version > 9 ? item.label : item.data.label)}`);\\n        list.push(`<img class=\\\"condition\\\" src=\\\"${(version > 9 ? item.icon : item.data.icon)}\\\" width=\\\"30\\\" height=\\\"30\\\" title=\\\"${(version > 9 ? item.label : item.data.label)}\\\"}>`);\\n        return list;\\n    }, []);\\n\\nif ((targetTempHp === maxPosTemp) && (targetInflicted.length === 0)) {\\n    let chatContent = `<div class=\\\"midi-qol-nobox\\\"><div class=\\\"midi-qol-flex-container\\\"><div>Nothing to Heal or Cure:</div><div class=\\\"midi-qol-target-npc midi-qol-target-name\\\" id=\\\"${target.document.id}\\\"> ${target.actor.name}</div><div><img src=\\\"${version > 9 ? target.document.texture.src : target.document.data.img}\\\" width=\\\"30\\\" height=\\\"30\\\" style=\\\"border:0px\\\"></img></div></div></div>`;\\n    await wait(500);\\n    const chatMessage = game.messages.get(lastArg.itemCardId);\\n    let content = duplicate((version > 9 ? chatMessage.content : chatMessage.data.content));\\n    const searchString = /<div class=\\\"midi-qol-hits-display\\\">[\\\\s\\\\S]*<div class=\\\"end-midi-qol-hits-display\\\">/g;\\n    const replaceString = `<div class=\\\"midi-qol-hits-display\\\"><div class=\\\"end-midi-qol-hits-display\\\">${chatContent}`;\\n    content = content.replace(searchString, replaceString);\\n    chatMessage.update({ content: content });\\n    await ui.chat.scrollBottom();\\n    return await game.user.updateTokenTargets([]);\\n}\\n\\nif ((targetTempHp != maxPosTemp) && (damageRoll.total > targetTempHp)) {\\n    aButtons[heal] = {\\n        icon: `<img src=\\\"icons/magic/life/cross-area-circle-green-white.webp\\\" width=\\\"30\\\" height=\\\"30\\\">`,\\n        label: \\\"Heal\\\",\\n        callback: async (html) => {\\n            await game.dice3d?.showForRoll(damageRoll);\\n            await new MidiQOL.DamageOnlyWorkflow(actorD, tokenD, damageRoll.total, damageType, [target], damageRoll, { flavor: `(${CONFIG.DND5E.healingTypes[damageType]})`, itemCardId: lastArg.itemCardId, useOther: false });\\n            await ui.chat.scrollBottom();\\n            return await game.user.updateTokenTargets([]);\\n        }\\n    }\\n}\\n\\nif (targetInflicted.length > 0) {\\n    aButtons[cure] = {\\n        icon: `<img src=\\\"icons/magic/holy/prayer-hands-glowing-yellow.webp\\\" width=\\\"30\\\" height=\\\"30\\\">`,\\n        label: \\\"Cure\\\", callback: async () => {\\n            let condition_list = [\\\"Charmed\\\", \\\"Frightened\\\"];\\n            let effect = target.actor.effects.filter(i => condition_list.includes((version > 9 ? i.label : i.data.label)));\\n            let selectOptions = \\\"\\\";\\n            for (let i = 0; i < effect.length; i++) {\\n                let condition = (version > 9 ? effect[i].label : effect[i].data.label);\\n                selectOptions += `<option value=\\\"${condition}\\\">${condition}</option>`;\\n            }\\n            if (selectOptions === \\\"\\\") {\\n                return ui.notifications.warn(`There's nothing to Cure on ${target.name}.`);\\n            } else {\\n                let content_cure = `<p>Choose a Condition Cure</p><form class=\\\"flexcol\\\"><div class=\\\"form-group\\\"><select id=\\\"element\\\">${selectOptions}</select></div></form>`;\\n                await new Dialog({\\n                    title: itemD.name,\\n                    content: content_cure,\\n                    buttons: {\\n                        cure: {\\n                            icon: `<img src=\\\"icons/magic/holy/prayer-hands-glowing-yellow.webp\\\" width=\\\"30\\\" height=\\\"30\\\">`,\\n                            label: 'Cure!',\\n                            callback: async (html) => {\\n                                let element = html.find('#element').val();\\n                                let effect = target.actor.effects.find(i => (version > 9 ? i.label : i.data.label) === element);\\n                                if (effect) await MidiQOL.socket().executeAsGM(\\\"removeEffects\\\", { actorUuid: target.actor.uuid, effects: [effect.id] });\\n                                let chatContent = `<div class=\\\"midi-qol-nobox\\\"><div class=\\\"midi-qol-flex-container\\\"><div>Cures ${element}:</div><div class=\\\"midi-qol-target-npc midi-qol-target-name\\\" id=\\\"${target.document.id}\\\"> ${target.actor.name}</div><div><img src=\\\"${version > 9 ? target.document.texture.src : target.document.data.img}\\\" width=\\\"30\\\" height=\\\"30\\\" style=\\\"border:0px\\\"></img></div></div></div>`;\\n                                await wait(500);\\n                                const chatMessage = game.messages.get(lastArg.itemCardId);\\n                                let content = duplicate((version > 9 ? chatMessage.content : chatMessage.data.content));\\n                                const searchString = /<div class=\\\"midi-qol-hits-display\\\">[\\\\s\\\\S]*<div class=\\\"end-midi-qol-hits-display\\\">/g;\\n                                const replaceString = `<div class=\\\"midi-qol-hits-display\\\"><div class=\\\"end-midi-qol-hits-display\\\">${chatContent}`;\\n                                content = content.replace(searchString, replaceString);\\n                                chatMessage.update({ content: content });\\n                                await ui.chat.scrollBottom();\\n                                return await game.user.updateTokenTargets([]);\\n                            }\\n                        }\\n                    },\\n                    default: \\\"cure\\\",\\n                }).render(true);\\n            }\\n        }\\n    }\\n}\\n\\nif ((damageRoll.total <= targetTempHp) && (targetInflicted.length === 0)) {\\n    await game.dice3d?.showForRoll(damageRoll);\\n    return await new MidiQOL.DamageOnlyWorkflow(actorD, tokenD, damageRoll.total, damageType, [target], damageRoll, { flavor: `(${CONFIG.DND5E.healingTypes[damageType]})`, itemCardId: lastArg.itemCardId, useOther: false });\\n}\\n\\n\\nlet finalButtons = Object.values(aButtons);\\nif (finalButtons.length === 1) return await game.user.updateTokenTargets([]);\\nawait new Dialog({\\n    title: `${itemD.name} : Choose an Effect`,\\n    content: `<style>#twilightInfo img{border:none}#twilightInfo{padding:10px}#twilightInfo .target{margin-right:10px}#twilightInfo .condition{border:1px solid red!important;margin:2px 5px}#twilightInfo ul{list-style:none}#twilightInfo ul li{float:left;margin-right:5px}</style><div id=\\\"twilightInfo\\\" class=\\\"form-group\\\"><ul><li><img class=\\\"target\\\" src=\\\"${version > 9 ? target.document.texture.src : target.document.data.img}\\\" height=\\\"40\\\" width=\\\"40\\\" title=\\\"${target.actor.name}\\\"></li><li><div><b>Target:</b> ${target.actor.name}</div><div><b>Temp HP:</b> ${targetTempHp != null ? targetTempHp : 0} / ${maxPosTemp}</div></li><li><div>${targetInflicted.join('')}</div></li></ul></div>`,\\n    buttons: aButtons,\\n    default: cancel\\n}).render(true);\",\n          \"folder\": null,\n          \"sort\": 0,\n          \"permission\": {\n            \"default\": 0\n          }\n        }\n      }\n    }\n  };\n  itemData[`${version > 9 ? \"system\" : \"data\"}`] = {\n    \"description\": {\n      \"value\": \"<p>Whenever a creature (including you) ends its turn in the sphere, you can grant that creature one of these benefits:</p>\\n<ul>\\n<li>You grant it temporary hit points equal to 1d6 plus your cleric level.</li>\\n</ul>\\n<ul>\\n<li>You end one effect on it causing it to be charmed or frightened.</li>\\n</ul>\"\n    },\n    \"duration\": {\n      \"value\": null,\n      \"units\": \"\"\n    },\n    \"range\": {\n      \"value\": 30,\n      \"long\": null,\n      \"units\": \"ft\"\n    },\n    \"actionType\": \"util\"\n  }\n  let findItems = await tactor.itemTypes.feat.reduce((list, item) => {\n    if (version > 9 ? (item.flags.itemCreated?.actorId) : (item.data.flags.itemCreated?.actorId)) list.push(item.id);\n    else return list;\n    return list;\n  }, []);\n  if (findItems.length > 0) {\n    console.warn(`Twilight Sanctuary`, `Removing`);\n    await tactor.deleteEmbeddedDocuments(\"Item\", findItems);\n  }\n  console.warn(`Twilight Sanctuary`, `Creating item`);\n  await tactor.createEmbeddedDocuments(\"Item\", [itemData]);\n  console.groupEnd(`Twilight Sanctuary => Starting`);\n}\n\nif (args[0] === \"off\") {\n  console.group(`Twilight Sanctuary => Removal`);\n  let findItems = await tactor.itemTypes.feat.reduce((list, item) => {\n    if (version > 9 ? (item.flags.itemCreated?.actorId) : (item.data.flags.itemCreated?.actorId)) list.push(item.id);\n    else return list;\n    return list;\n  }, []);\n  if (findItems.length > 0) {\n    console.warn(`Twilight Sanctuary`, `Removing`);\n    await tactor.deleteEmbeddedDocuments(\"Item\", findItems);\n  }\n  let hookId = await DAE.getFlag(tactor, \"twilightEffect\");\n  if (hookId) {\n    console.warn(`Twilight Sanctuary`, `Deleting`, `Hooks`);\n    Hooks.off(\"updateCombat\", hookId);\n    await DAE.unsetFlag(tactor, \"twilightEffect\");\n  }\n  console.groupEnd(`Twilight Sanctuary => Removal`);\n}","folder":null,"sort":0,"permission":{"default":0},"flags":{}}},"core":{"sourceId":"Item.2cCaIxxPXmNzWSKb"},"favtab":{"isFavorite":true},"exportSource":{"world":"darklands","system":"dnd5e","coreVersion":"9.280","systemVersion":"1.6.3"}},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":1669440918456,"modifiedTime":1669440918456,"lastModifiedBy":"T4cu5jv0VXcrhb1w"},"_id":"GVGfOwrcStPvtMo5","folder":null,"sort":0,"ownership":{"default":0,"T4cu5jv0VXcrhb1w":3}}
{"name":"Favored Foe","type":"spell","img":"icons/skills/targeting/crosshair-pointed-orange.webp","system":{"description":{"value":"<p data-content-chunk-id=\"4a3e5f32-acb8-43db-818b-37d1302e8fa8\">When you hit a creature with an attack roll, you can call on your mystical bond with nature to mark the target as your favored enemy for 1 minute or until you lose your concentration (as if you were concentrating on a spell).</p>\n<p data-content-chunk-id=\"7db745a2-977a-4432-a38e-91d1a26760b2\">The first time on each of your turns that you hit the favored enemy and deal damage to it, including when you mark it, you can increase that damage by 1d4.</p>\n<p data-content-chunk-id=\"3bfda3fe-fdd9-4c20-b20c-5d456ca1cbb0\">You can use this feature to mark a favored enemy a number of times equal to your proficiency bonus, and you regain all expended uses when you finish a long rest.</p>\n<p data-content-chunk-id=\"fcb93e19-8eb5-4200-ba15-f27ace0dc962\">This feature’s extra damage increases when you reach certain levels in this class: to 1d6 at 6th level and to 1d8 at 14th level.</p>","chat":"","unidentified":""},"source":"","activation":{"type":"special","cost":null,"condition":""},"duration":{"value":1,"units":"minute"},"target":{"value":1,"width":null,"units":"","type":"creature"},"range":{"value":60,"long":null,"units":"ft"},"uses":{"value":null,"max":"","per":"","recovery":""},"consume":{"type":"attribute","target":"","amount":1},"ability":"","actionType":"util","attackBonus":0,"chatFlavor":"","critical":{"threshold":null,"damage":null},"damage":{"parts":[],"versatile":""},"formula":"","save":{"ability":"","dc":null,"scaling":"spell"},"level":0,"school":"enc","components":{"value":"","vocal":false,"somatic":false,"material":false,"ritual":false,"concentration":true},"materials":{"value":"","consumed":false,"cost":0,"supply":0},"preparation":{"mode":"atwill","prepared":true},"scaling":{"mode":"none","formula":""}},"effects":[{"_id":"QeFbXAbsgp1AYAGs","changes":[],"disabled":false,"duration":{"startTime":null,"seconds":3600,"combat":null,"rounds":null,"turns":null,"startRound":null,"startTurn":null},"icon":"icons/skills/targeting/crosshair-pointed-orange.webp","label":"Favored Foe","transfer":false,"flags":{"dae":{"stackable":"none","macroRepeat":"none","specialDuration":["zeroHP"],"transfer":false,"selfTarget":false,"durationExpression":""},"core":{"statusId":""},"dnd5e-helpers":{"rest-effect":"Ignore"},"ActiveAuras":{"isAura":false,"aura":"None","radius":null,"alignment":"","type":"","ignoreSelf":false,"height":false,"hidden":false,"displayTemp":false,"hostile":false,"onlyOnce":false}},"tint":null,"origin":null}],"flags":{"itemacro":{"macro":{"data":{"_id":null,"name":"Favored Foe","type":"script","author":"Tyd5yiqWrRZMvG30","img":"icons/svg/dice-target.svg","scope":"global","command":"////////////////////////////////////////////////\n// #READ FIRST\n// # Remade version of Hunters Mark by Tposney\n// # Requires Midi-qol On Use\n// # Create Item as a Cantrip At-will for concentration ease\n///////////////////////////////////////////////\nasync function wait(ms) { return new Promise(resolve => { setTimeout(resolve, ms); }); }\nconst lastArg = args[args.length - 1];\nconst tokenD = canvas.tokens.get(lastArg.tokenId);\nconst actorD = tokenD.actor;\nconst actorData = actorD.getRollData();\nconst classLevel = actorData.details.cr ?? actorData.classes.ranger.levels;\nconst itemD = lastArg.item;\nlet targetUuid;\nlet effectData;\n\nif (args[0].targets.length === 0) return {};\nif (args[0].tag === \"OnUse\") {\n    targetUuid = lastArg.targets[0].uuid;\n    let tactortUuid = lastArg.targets[0].actor.uuid;\n    if (!targetUuid) return console.error(\"Favored Foe: no token/target selected\");\n    let conc = actorD.effects.find(i => i.data.label === \"Concentrating\");\n    if (conc) {\n        let concUpdate = await getProperty(actorD.data.flags, \"midi-qol.concentration-data.targets\");\n        await concUpdate.push({ tokenUuid: targetUuid, actorUuid: tactortUuid });\n        await actorD.setFlag(\"midi-qol\", \"concentration-data.targets\", concUpdate);\n    }\n    effectData = {\n        changes: [\n            { key: \"flags.midi-qol.favoredFoe\", mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE, value: targetUuid, priority: 20 },\n            { key: \"flags.dae.deleteUuid\", mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE, value: conc.uuid, priority: 20 },\n            { key: \"flags.dnd5e.DamageBonusMacro\", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: `ItemMacro.${itemD.name}`, priority: 20 }\n        ],\n        origin: lastArg.itemUuid,\n        disabled: false,\n        flags: { dae: { stackable: \"noneOrigin\", tokenId: tokenD.id, itemData: itemD } },\n        duration: duplicate(itemD.effects[0].duration),\n        icon: itemD.img,\n        label: itemD.name\n    }\n    effectData.duration.startTime = game.time.worldTime;\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: actorD.uuid, effects: [effectData] });\n    await wait(1000);\n    let target = await canvas.tokens.get(lastArg.targets[0].id);\n    let effect = target.actor.effects.find(i => i.data.label === itemD.name);\n    if (effect) {\n        let updateData = {\n            _id: effect.id,\n            changes: [\n                { key: \"flags.dae.deleteUuid\", mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE, value: conc.uuid, priority: 20 }\n            ],\n            duration: duplicate(itemD.effects[0].duration)\n        }\n        await MidiQOL.socket().executeAsGM(\"updateEffects\", { actorUuid: target.actor.uuid, updates: [updateData] });\n    }\n}\n\nif (args[0].tag === \"DamageBonus\") {\n    if (![\"mwak\", \"rwak\"].includes(itemD.data.actionType)) return {};\n    targetUuid = lastArg.hitTargets[0].uuid;\n    let favoredFoe = actorD.items.getName(\"Favored Foe\");\n    if (targetUuid !== getProperty(lastArg.actor.data.flags, \"midi-qol.favoredFoe\")) return {};\n    if (actorD.effects.find(i => i.data.label === `${favoredFoe.name} Effect`)) return {};\n    let gameRound = game.combat ? game.combat.round : 0;\n    effectData = {\n        label: `${favoredFoe.name} Effect`,\n        icon: favoredFoe.img,\n        tint: \"#8f0000\",\n        origin: favoredFoe.uuid,\n        flags: { dae: { stackable: \"noneName\", tokenId: tokenD.id, itemData: itemD, specialDuration: [\"turnEndSource\", \"turnStartSource\"] } },\n        duration: { turns: 1, startRound: gameRound, startTime: game.time.worldTime }\n    };\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: actorD.uuid, effects: [effectData] });\n    let damageType = lastArg.defaultDamageType ?? lastArg.damageDetail.map(i => i.type)[0];\n    let dieFace = classLevel >= 14 ? 8 : classLevel >= 6 ? 6 : 4;\n    let damangeDice = await new game.dnd5e.dice.DamageRoll(`1d${dieFace}[${damageType}]`, actorData, { critical: lastArg.isCritical }).evaluate({ async: true });\n    return { damageRoll: damangeDice.formula, flavor: `(${favoredFoe.name} (${CONFIG.DND5E.damageTypes[damageType]}))` };\n}","folder":null,"sort":0,"permission":{"default":0},"flags":{}}}},"core":{"sourceId":"Item.99mweYiHXGE9UvRz"},"midi-qol":{"onUseMacroName":"[postActiveEffects]ItemMacro","effectActivation":false},"favtab":{"isFavorite":true},"exportSource":{"world":"darklands","system":"dnd5e","coreVersion":"9.269","systemVersion":"1.6.3"},"enhanced-terrain-layer":{"multiple":1,"min":0,"max":0,"environment":""},"midiProperties":{"nodam":false,"fulldam":false,"halfdam":false,"rollOther":false,"critOther":false,"magicdam":false,"magiceffect":false,"concentration":false,"toggleEffect":false}},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":1669440918461,"modifiedTime":1669440918461,"lastModifiedBy":"T4cu5jv0VXcrhb1w"},"_id":"GuDU3PvD2G6EpLKz","folder":null,"sort":0,"ownership":{"default":0,"T4cu5jv0VXcrhb1w":3}}
{"name":"Divine Strike","type":"feat","img":"icons/skills/melee/weapons-crossed-swords-yellow-teal.webp","system":{"description":{"value":"<p>You gain the ability to infuse your weapon strikes with divine energy. Once on each of your turns when you hit a creature with a weapon attack, you can cause the attack to deal an extra 1d8 psychic damage to the target.</p>\n<p>When you reach 14th level, the extra damage increases to 2d8.</p>","chat":"","unidentified":""},"source":"PHB pg. 85","activation":{"type":"","cost":null,"condition":""},"duration":{"value":null,"units":""},"target":{"value":null,"width":null,"units":"","type":""},"range":{"value":null,"long":null,"units":""},"uses":{"value":0,"max":0,"per":"","recovery":"","type":""},"consume":{"type":"","target":"","amount":null},"ability":"","actionType":"","attackBonus":0,"chatFlavor":"","critical":{"threshold":null,"damage":null},"damage":{"parts":[],"versatile":"1d8"},"formula":"","save":{"ability":"","dc":null,"scaling":"spell","value":""},"requirements":"Cleric 8","recharge":{"value":null,"charged":false},"attributes":{"spelldc":10},"attunement":null},"effects":[{"_id":"9BkyVV0yaQ7Te48m","changes":[{"key":"flags.dnd5e.DamageBonusMacro","mode":0,"value":"ItemMacro.Divine Strike","priority":20}],"disabled":false,"duration":{"startTime":null,"seconds":null,"combat":null,"rounds":null,"turns":null,"startRound":null,"startTurn":null},"icon":"icons/skills/melee/weapons-crossed-swords-yellow-teal.webp","label":"Divine Strike","transfer":true,"flags":{"dae":{"stackable":"none","macroRepeat":"none","specialDuration":[],"transfer":true,"durationExpression":"","selfTarget":false},"dnd5e-helpers":{"rest-effect":"Ignore"},"ActiveAuras":{"isAura":false,"aura":"None","radius":null,"alignment":"","type":"","ignoreSelf":false,"height":false,"hidden":false,"hostile":false,"onlyOnce":false,"displayTemp":false},"core":{"statusId":""}},"tint":null,"origin":null}],"flags":{"core":{"sourceId":"Compendium.dnd5e.classfeatures.ySMPQ6zNSlvkrl2f"},"itemacro":{"macro":{"data":{"_id":null,"name":"Divine Strike","type":"script","author":"Tyd5yiqWrRZMvG30","img":"icons/svg/dice-target.svg","scope":"global","command":"// Open up the Special Traits window on your Cleric's sheet, then locate DAE.Midi-QOL Specific Bonus Damage Macros. There enter the name of the macro, whatever you named it.\nif (args[0].tag === \"DamageBonus\") {\n    const lastArg = args[args.length - 1];\n    let actorD = canvas.tokens.get(lastArg.tokenId).actor;    \n    let attackList = actorD.itemTypes.weapon.filter(i => i.hasDamage).map(i => i.name.toLowerCase());\n    let itemD = lastArg.item;\n    let legalAttack = attackList.some(i => (itemD.name).toLowerCase().includes(i));\n    if (!legalAttack) return {};\n    let originD = actorD.items.getName(\"Divine Strike\");\n    let effect = actorD.effects.find(i => i.data.label === `${originD.name} Attack`);\n    if (effect) return {};\n    let level = actorD.getRollData().classes.cleric.levels;\n    let damageType = \"psychic\";\n    let numDice = level > 16 ? 2 : 1;\n    let damageRoll = new game.dnd5e.dice.DamageRoll(`${numDice}d8[${damageType}]`, actorD.getRollData(), { critical: lastArg.isCritical }).evaluate({ async: false });\n    let gameRound = game.combat ? game.combat.round : 0;\n    let effectData = {\n        label: `${originD.name} Attack`,\n        icon: originD.img,\n        tint: \"#8f0000\",\n        origin: originD.uuid,\n        duration: { turns: 1, startRound: gameRound, startTime: game.time.worldTime }\n    };\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: actorD.uuid, effects: [effectData] });\n    return { damageRoll: damageRoll.formula, flavor: `(${originD.name} (${CONFIG.DND5E.damageTypes[damageType]}))` };\n}","folder":null,"sort":0,"permission":{"default":0},"flags":{}},"_id":null,"name":"Divine Strike","type":"script","author":"Tyd5yiqWrRZMvG30","img":"icons/svg/dice-target.svg","scope":"global","command":"// Open up the Special Traits window on your Cleric's sheet, then locate DAE.Midi-QOL Specific Bonus Damage Macros. There enter the name of the macro, whatever you named it.\nif (args[0].tag === \"DamageBonus\") {\n    const lastArg = args[args.length - 1];\n    const version = Math.floor(game.version);\n    let actorD = canvas.tokens.get(lastArg.tokenId).actor;    \n    let attackList = actorD.itemTypes.weapon.filter(i => i.hasDamage).map(i => i.name.toLowerCase());\n    let itemD = lastArg.item;\n    let legalAttack = attackList.some(i => (itemD.name).toLowerCase().includes(i));\n    if (!legalAttack) return {};\n    let originD = actorD.items.getName(\"Divine Strike\");\n    let effect = actorD.effects.find(i => (version > 9 ? i.label : i.data.label) === `${originD.name} Attack`);\n    if (effect) return {};\n    let level = actorD.getRollData().classes.cleric.levels;\n    let damageType = \"psychic\";\n    let numDice = level >= 14 ? 2 : 1;\n    let damageRoll = await new game.dnd5e.dice.DamageRoll(`${numDice}d8[${damageType}]`, actorD.getRollData(), { critical: lastArg.isCritical }).evaluate({ async: true });\n    let gameRound = game.combat ? game.combat.round : 0;\n    let effectData = {\n        label: `${originD.name} Attack`,\n        icon: originD.img,\n        tint: \"#8f0000\",\n        transfer: false,\n        origin: originD.uuid,\n        duration: { turns: 1, startRound: gameRound, startTime: game.time.worldTime }\n    };\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: actorD.uuid, effects: [effectData] });\n    return { damageRoll: damageRoll.formula, flavor: `(${originD.name} (${CONFIG.DND5E.damageTypes[damageType]}))` };\n}","folder":null,"sort":0,"permission":{"default":0},"flags":{}}},"midi-qol":{"onUseMacroName":"","effectActivation":false},"magicitems":{"enabled":false,"equipped":false,"attuned":false,"charges":"0","chargeType":"c1","destroy":false,"destroyFlavorText":"reaches 0 charges: it crumbles into ashes and is destroyed.","rechargeable":false,"recharge":"0","rechargeType":"t1","rechargeUnit":"r1","sorting":"l"},"autoanimations":{"killAnim":false,"override":false,"animType":"t1","animName":"","color":"n1","dtvar":"dt1","explosion":false,"explodeVariant":"ev1","explodeColor":"","explodeRadius":"0","explodeLoop":"1","hmAnim":"a1","uaStrikeType":"physical","selfRadius":"5","animTint":"#ffffff","auraOpacity":0.75,"ctaOption":false,"bards":{"bardAnim":"a1","bardTarget":true,"bardSelf":true},"spellVar":"a1","spellOptions":{"spellLoops":1},"teleDist":30},"betterCurses":{"isCurse":false,"curseName":"","formula":"","mwak":false,"rwak":false,"msak":false,"rsak":false},"innocenti-openlock":{"enabled":false,"keylock":"","wallCoord":"","disarmTrap":10,"findTrap":10,"skillfindTrap":"prc","passive":10,"forceLock":12,"openLock":10,"toolsBreak":5},"favtab":{"isFavorite":false},"exportSource":{"world":"darklands","system":"dnd5e","coreVersion":"9.280","systemVersion":"1.6.3"},"midiProperties":{"nodam":false,"fulldam":false,"halfdam":false,"rollOther":false,"critOther":false,"magicdam":false,"magiceffect":false,"concentration":false,"toggleEffect":false}},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":1669440918458,"modifiedTime":1669440918458,"lastModifiedBy":"T4cu5jv0VXcrhb1w"},"_id":"JIAclQHN4fUBW9EY","folder":null,"sort":0,"ownership":{"default":0,"T4cu5jv0VXcrhb1w":3}}
{"name":"Great Weapon Master","type":"feat","img":"icons/weapons/axes/axe-battle-skull-black.webp","system":{"description":{"value":"<p>You've learned to put the weight of a weapon to your advantage, letting its momentum empower your strikes. You gain the following benefits:</p>\n<ul>\n<li>On your turn, when you score a critical hit with a melee weapon or reduce a creature to 0 hit points with one, you can make one melee weapon attack as a bonus action.</li>\n<li>Before you make a melee attack with a heavy weapon that you are proficient with, you can choose to take a -5 penalty to the attack roll. If the attack hits, you add +10 to the attack's damage.</li>\n</ul>\n\n","chat":"On your turn, when you score a critical hit with a melee weapon or reduce a creature to 0 HP with one, you can make one melee weapon attack as a bonus action. Before you make a melee attack with a heavy weapon that you are proficient with, you can choose to take a -5 penalty to the attack roll to add +10 to the attack's damage.\n\n","unidentified":""},"source":"Player's Handbook pg 167","activation":{"type":"special","cost":0,"condition":""},"duration":{"value":null,"units":""},"target":{"value":null,"width":null,"units":"","type":"self"},"range":{"value":null,"long":null,"units":"self"},"uses":{"value":null,"max":"","per":"","recovery":""},"consume":{"type":"","target":"","amount":null},"ability":"","actionType":"util","attackBonus":0,"chatFlavor":"","critical":{"threshold":null,"damage":""},"damage":{"parts":[],"versatile":""},"formula":"","save":{"ability":"","dc":null,"scaling":"spell"},"requirements":"","recharge":{"value":null,"charged":false}},"effects":[],"flags":{"itemacro":{"macro":{"data":{"_id":null,"name":"Great Weapon Master","type":"script","author":"Tyd5yiqWrRZMvG30","img":"icons/weapons/axes/axe-battle-skull-black.webp","scope":"global","command":"//#####################################\n// READ THIS\n// Requires Midi-QoL on use\n//####################################\nconst lastArg = args[args.length - 1];\nlet tactor;\nif (lastArg.tokenId) tactor = canvas.tokens.get(lastArg.tokenId).actor;\nelse tactor = game.actors.get(lastArg.actorId);\nconst itemD = lastArg.item;\nconst gameRound = game.combat ? game.combat.round : 0;\nlet the_message = \"\";\nlet effect = await tactor.effects.find(ef => ef.data.label === itemD.name);\nif (effect) {    \n    await MidiQOL.socket().executeAsGM(\"removeEffects\", { actorUuid: tactor.uuid, effects: [effect.id] });    \n    the_message = `<em>${tactor.name} is swinging <strong>Normally</strong> now.</em>`;\n} else {\n    let effectData = [{\n        label: itemD.name,\n        icon: itemD.img,\n        duration: { rounds: 1, startRound: gameRound, startTime: game.time.worldTime },\n        origin: lastArg.uuid,\n        changes: [\n         {\"key\": \"data.bonuses.mwak.damage\", \"mode\": CONST.ACTIVE_EFFECT_MODES.CUSTOM, \"value\": 10, \"priority\": 20},\n         {\"key\": \"data.bonuses.mwak.attack\", \"mode\": CONST.ACTIVE_EFFECT_MODES.CUSTOM, \"value\": \"-5\", \"priority\": 20}\n         ]\n    }];\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: tactor.uuid, effects: effectData });    \n    the_message = `<em>${tactor.name} is swinging <strong>Harder</strong> now!</em>`;\n}\nlet chatMessage = game.messages.get(lastArg.itemCardId);\nlet content = await duplicate(chatMessage.data.content);\nlet searchString = /<div class=\"midi-qol-saves-display\">[\\s\\S]*<div class=\"end-midi-qol-saves-display\">/g;\nlet replaceString = `<div class=\"midi-qol-saves-display\"><div class=\"end-midi-qol-saves-display\">${the_message}`;\ncontent = content.replace(searchString, replaceString);\nawait chatMessage.update({ content: content });\nawait ui.chat.scrollBottom();","folder":null,"sort":0,"permission":{"default":0},"flags":{}}}},"midi-qol":{"onUseMacroName":"[postActiveEffects]ItemMacro","effectActivation":false,"forceCEOff":true,"forceCEOn":false},"favtab":{"isFavorite":true},"midiProperties":{"nodam":false,"fulldam":false,"halfdam":false,"rollOther":false,"critOther":false,"magicdam":false,"magiceffect":false,"concentration":false,"toggleEffect":false,"ignoreTotalCover":false}},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":1669440918462,"modifiedTime":1669440935530,"lastModifiedBy":"T4cu5jv0VXcrhb1w"},"_id":"P25DZT9vX2FMYCNd","folder":null,"sort":0,"ownership":{"default":0,"T4cu5jv0VXcrhb1w":3}}
{"name":"Colossus Slayer","type":"feat","img":"icons/creatures/magical/humanoid-giant-forest-blue.webp","system":{"description":{"value":"<p>Your tenacity can wear down the most potent foes. When you hit a creature with a weapon attack, the creature takes an extra 1d8 damage if it’s below its hit point maximum. You can deal this extra damage only o<span class=\"No-Break\">nce per turn.</span></p><h3>Summary</h3>Once per turn, when you hit a creature with a weapon attack, the creature takes an extra 1d8 damage if it’s below its HP maximum.","chat":"Once per turn, when you hit a creature with a weapon attack, the creature takes an extra 1d8 damage if it’s below its HP maximum.","unidentified":""},"source":"","activation":{"type":"special","cost":1,"condition":""},"duration":{"value":null,"units":""},"target":{"value":null,"width":null,"units":"","type":""},"range":{"value":null,"long":null,"units":""},"uses":{"value":null,"max":"","per":"","recovery":""},"consume":{"type":"","target":"","amount":null},"ability":"","actionType":"other","attackBonus":0,"chatFlavor":"","critical":{"threshold":null,"damage":null},"damage":{"parts":[],"versatile":""},"formula":"","save":{"ability":"","dc":null,"scaling":"spell"},"requirements":"","recharge":{"value":null,"charged":false}},"effects":[{"_id":"PHUHW2gr7AzSPCBn","changes":[{"key":"flags.dnd5e.DamageBonusMacro","mode":0,"value":"ItemMacro.Colossus Slayer","priority":20}],"disabled":false,"duration":{"startTime":null,"seconds":null,"combat":null,"rounds":null,"turns":null,"startRound":null,"startTurn":null},"icon":"icons/creatures/magical/humanoid-giant-forest-blue.webp","label":"Colossus Slayer","transfer":true,"flags":{"dae":{"stackable":"none","macroRepeat":"none","specialDuration":[],"transfer":true},"dnd5e-helpers":{"rest-effect":"Ignore"},"ActiveAuras":{"isAura":false,"aura":"None","radius":null,"alignment":"","type":"","ignoreSelf":false,"height":false,"hidden":false,"hostile":false,"onlyOnce":false}},"tint":null,"origin":null}],"flags":{"ddbimporter":{"id":"70702","entityTypeId":"222216831","componentId":95,"componentTypeId":258900837},"midi-qol":{"onUseMacroName":"","effectActivation":false},"magicitems":{"enabled":false,"equipped":false,"attuned":false,"charges":"0","chargeType":"c1","destroy":false,"destroyFlavorText":"reaches 0 charges: it crumbles into ashes and is destroyed.","rechargeable":false,"recharge":"0","rechargeType":"t1","rechargeUnit":"r1","sorting":"l"},"core":{"sourceId":"Item.TTDaBEbKwvjHkwwu"},"itemacro":{"macro":{"data":{"_id":null,"name":"Colossus Slayer","type":"script","author":"Tyd5yiqWrRZMvG30","img":"icons/svg/dice-target.svg","scope":"global","command":"if (args[0].tag === \"DamageBonus\") {\n    let target = canvas.tokens.get(args[0].targets[0].id);\n    if(target.actor.data.data.attributes.hp.value === target.actor.data.data.attributes.hp.max) return {};\n    if (![\"mwak\", \"rwak\"].includes(args[0].item.data.actionType)) return {};\n    let tokenD = canvas.tokens.get(args[0].tokenId);\n    let damageType = args[0].damageDetail[0].type;\n    let numDice = args[0].isCritical ? 2 : 1;\n    let itemD = tokenD.actor.items.getName(\"Colossus Slayer\");\n    if (tokenD.actor.effects.find(i => i.data.label === `${itemD.name} Attack`)) return {};\n    let gameRound = game.combat ? game.combat.round : 0;\n    let effectData = {\n        label: `${itemD.name} Attack`,\n        icon: itemD.img,\n        origin: itemD.uuid,\n        duration: { turns: 1, startRound: gameRound, startTime: game.time.worldTime }\n    };\n    await tokenD.actor.createEmbeddedDocuments(\"ActiveEffect\", [effectData]);\n    return { damageRoll: `${numDice}d8[${damageType}]`, flavor: `(${itemD.name} (${CONFIG.DND5E.damageTypes[damageType]}))` };\n}","folder":null,"sort":0,"permission":{"default":0},"flags":{}}}},"exportSource":{"world":"darklands","system":"dnd5e","coreVersion":"0.8.9","systemVersion":"1.5.2"},"midiProperties":{"nodam":false,"fulldam":false,"halfdam":false,"rollOther":false,"critOther":false,"magicdam":false,"magiceffect":false,"concentration":false,"toggleEffect":false}},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":1669440918457,"modifiedTime":1669440918457,"lastModifiedBy":"T4cu5jv0VXcrhb1w"},"_id":"PYpgZu0lSJXPHlVx","folder":null,"sort":0,"ownership":{"default":0,"T4cu5jv0VXcrhb1w":3}}
{"name":"Blessed Strikes","type":"feat","img":"icons/magic/symbols/runes-etched-steel-blade.webp","system":{"description":{"value":"<p>You are blessed with divine might in battle. When a creature takes damage from one of your cantrips or weapon attacks, you can also deal 1d8 radiant damage to that creature. Once you deal this damage, you can’t use this feature again until the start of your next turn.</p>","chat":"","unidentified":""},"source":"","activation":{"type":"","cost":0,"condition":""},"duration":{"value":null,"units":""},"target":{"value":null,"width":null,"units":"","type":""},"range":{"value":null,"long":null,"units":""},"uses":{"value":0,"max":0,"per":null,"recovery":""},"consume":{"type":"","target":null,"amount":null},"ability":null,"actionType":"","attackBonus":0,"chatFlavor":"","critical":{"threshold":null,"damage":null},"damage":{"parts":[],"versatile":""},"formula":"","save":{"ability":"","dc":null,"scaling":"spell"},"requirements":"Cleric 8","recharge":{"value":null,"charged":false},"attunement":null},"effects":[{"_id":"1WYUO87U4LT1EDWN","changes":[{"key":"flags.dnd5e.DamageBonusMacro","mode":0,"value":"ItemMacro.Blessed Strikes","priority":20}],"disabled":false,"duration":{"startTime":null,"seconds":null,"combat":null,"rounds":null,"turns":null,"startRound":null,"startTurn":null},"icon":"icons/magic/symbols/runes-etched-steel-blade.webp","label":"Blessed Strikes","transfer":true,"flags":{"dae":{"stackable":"none","macroRepeat":"none","specialDuration":[],"transfer":true,"durationExpression":""},"dnd5e-helpers":{"rest-effect":"Ignore"},"ActiveAuras":{"isAura":false,"aura":"None","radius":null,"alignment":"","type":"","ignoreSelf":false,"height":false,"hidden":false,"hostile":false,"onlyOnce":false,"displayTemp":false},"core":{"statusId":""}},"tint":null,"origin":null}],"flags":{"itemacro":{"macro":{"data":{"_id":null,"name":"Blessed Strikes","type":"script","author":"Tyd5yiqWrRZMvG30","img":"icons/svg/dice-target.svg","scope":"global","command":"if((args[0].tag === \"DamageBonus\") && ((args[0].hitTargets.length > 0) || (args[0].failedSaves.legnth > 0))){    \n\tlet tokenD = canvas.tokens.get(args[0].tokenId);\n\tlet weapons = tokenD.actor.itemTypes.weapon.filter(i=> i.hasDamage).map(i=> i.name.toLowerCase());\n\tlet spells = tokenD.actor.itemTypes.spell.filter(i=> i.hasDamage && i.data.data.level === 0).map(i=> i.name.toLowerCase());\n\tlet attackList = weapons.concat(spells);\n    let itemD = args[0].item;\n\tlet legalAttack = attackList.some(i => (itemD.name).toLowerCase().includes(i));\n    if(!legalAttack) return {};    \n    let level = tokenD.actor.classes.cleric?.data.data.levels || tokenD.actor.data.data.details.cr;\n    let damageType = \"radiant\";\n    let numDice = level > 16 ? 2 : 1;\t\n    let originD = tokenD.actor.items.find(i=> i.name === \"Blessed Strikes\");    \n\tlet effect = tokenD.actor.effects.find(i=> i.data.label === `${originD.name} Attack`);\n\tif(effect) return {};\n\tlet damageRoll = new game.dnd5e.dice.DamageRoll(`${numDice}d8[${damageType}]`, {},  {critical: args[0].isCritical}).evaluate({async:false});    \n    let gameRound = game.combat ? game.combat.round : 0;\n    let effectData = {\n      label : `${originD.name} Attack`,\n      icon : originD.img,\n      tint : \"#8f0000\",\n      origin: originD.uuid,\n      duration: {turns: 1, startRound: gameRound, startTime: game.time.worldTime}\n    };\t\n\tawait MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: tokenD.actor.uuid, effects: [effectData] });    \n    return { damageRoll: damageRoll.formula, flavor: `(${originD.name} (${CONFIG.DND5E.damageTypes[damageType]}))` };\n}","folder":null,"sort":0,"permission":{"default":0},"flags":{}},"_id":null,"name":"Blessed Strikes","type":"script","author":"Tyd5yiqWrRZMvG30","img":"icons/svg/dice-target.svg","scope":"global","command":"if ((args[0].tag === \"DamageBonus\") && ((args[0].hitTargets.length > 0) || (args[0].failedSaves.legnth > 0))) {\n    const lastArg = args[args.length - 1];\n    const version = Math.floor(game.version);\n    let actorD = canvas.tokens.get(lastArg.tokenId).actor;\n    let spells = actorD.itemTypes.spell.filter(i => i.hasDamage && (version > 9 ? i.level : i.data.data.level) === 0).map(i => i.name.toLowerCase());\n    let weapons = actorD.itemTypes.weapon.filter(i => i.hasDamage && (version > 9 ? i.level : i.data.data.actionType) === \"mwak\").map(i => i.name.toLowerCase());\n    let attackList = weapons.concat(spells);\n    let itemD = lastArg.item;\n    let legalAttack = attackList.some(i => (itemD.name).toLowerCase().includes(i));\n    if (!legalAttack) return {};    \n    let damageType = \"radiant\";    \n    let originD = actorD.items.find(i => i.name === \"Blessed Strikes\");\n    let effect = actorD.effects.find(i => (version > 9 ? i.label : i.data.label) === `${originD.name} Attack`);\n    if (effect) return {};\n    let damageRoll = await new game.dnd5e.dice.DamageRoll(`1d8[${damageType}]`, {}, { critical: lastArg.isCritical }).evaluate({ async: true });\n    let gameRound = game.combat ? game.combat.round : 0;\n    let effectData = {\n        label: `${originD.name} Attack`,\n        icon: originD.img,\n        tint: \"#8f0000\",\n        transfer: false,\n        origin: originD.uuid,\n        duration: { turns: 1, startRound: gameRound, startTime: game.time.worldTime }\n    };\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: actorD.uuid, effects: [effectData] });\n    return { damageRoll: damageRoll.formula, flavor: `(${originD.name} (${CONFIG.DND5E.damageTypes[damageType]}))` };\n}","folder":null,"sort":0,"permission":{"default":0},"flags":{}}},"magicitems":{"enabled":false,"equipped":false,"attuned":false,"charges":"0","chargeType":"c1","destroy":false,"destroyFlavorText":"reaches 0 charges: it crumbles into ashes and is destroyed.","rechargeable":false,"recharge":"0","rechargeType":"t1","rechargeUnit":"r1","sorting":"l"},"core":{"sourceId":"Item.sBVUwACtPz7aXZis"},"exportSource":{"world":"darklands","system":"dnd5e","coreVersion":"9.280","systemVersion":"1.6.3"}},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":1669440918453,"modifiedTime":1669440918453,"lastModifiedBy":"T4cu5jv0VXcrhb1w"},"_id":"R8vA4m3ESnoyKsUD","folder":null,"sort":0,"ownership":{"default":0,"T4cu5jv0VXcrhb1w":3}}
{"name":"Sneak Attack","type":"feat","img":"icons/skills/melee/strike-dagger-arcane-pink.webp","system":{"description":{"value":"<p>Beginning at 1st level, you know how to strike subtly and exploit a foe's distraction. Once per turn, you can deal an extra 1d6 damage to one creature you hit with an attack if you have advantage on the attack roll. The attack must use a finesse or a ranged weapon.</p>\n<p>You don't need advantage on the attack roll if another enemy of the target is within 5 feet of it, that enemy isn't incapacitated, and you don't have disadvantage on the attack roll.</p>","chat":"","unidentified":""},"source":"","activation":{"type":"bonus","cost":1,"condition":""},"duration":{"value":null,"units":""},"target":{"value":null,"width":null,"units":"","type":""},"range":{"value":null,"long":null,"units":""},"uses":{"value":0,"max":"0","per":"","recovery":""},"consume":{"type":"","target":"","amount":null},"ability":"","actionType":"util","attackBonus":0,"chatFlavor":"","critical":{"threshold":null,"damage":null},"damage":{"parts":[],"versatile":""},"formula":"","save":{"ability":"","dc":null,"scaling":"spell"},"requirements":"","recharge":{"value":null,"charged":false}},"effects":[],"flags":{"magicitems":{"enabled":false,"equipped":false,"attuned":false,"charges":"0","chargeType":"c1","destroy":false,"destroyFlavorText":"reaches 0 charges: it crumbles into ashes and is destroyed.","rechargeable":false,"recharge":"0","rechargeType":"t1","rechargeUnit":"r1","sorting":"l"},"favtab":{"isFavorite":true},"itemacro":{"macro":{"data":{"_id":null,"name":"Sneak Attack","type":"script","author":"Tyd5yiqWrRZMvG30","img":"icons/svg/dice-target.svg","scope":"global","command":"// Midi-qol on use\n// gets Weapon history and also prevents you from rolling if last attack was at Disadvantage\nconst lastArg = args[args.length - 1];\nlet actorD = game.actors.get(lastArg.actor._id);\nlet tokenD = canvas.tokens.get(lastArg.tokenId);\nlet itemD = lastArg.item;\nlet msgHistory = Object.values(MidiQOL.Workflow.workflows).filter(i => i.actor.id === actorD.id && i.workflowType === \"Workflow\" && i.item?.name != itemD.name);\nif (msgHistory.length === 0) return ui.notifications.error(`You need to successfully attack first.`);\nlet lastAttack = msgHistory[msgHistory.length - 1];\nlet target = lastAttack.hitTargets;\nif (lastAttack.disadvantage) return ui.notifications.warn(`You currently have disadvantage against this target`);\nlet damageType = lastAttack.defaultDamageType;\nlet level = actorD.classes?.rogue.data.data.levels;\nlet numDice = (Math.ceil(level / 2));\nlet damageRoll = lastAttack.isCritical ? new Roll(`${numDice * 2}d6[${damageType}]`).evaluate({ async: false }) : new Roll(`${numDice}d6[${damageType}]`).evaluate({ async: false });\nawait game.dice3d?.showForRoll(damageRoll);\nlet damageWorkflow = new MidiQOL.DamageOnlyWorkflow(actorD, tokenD, damageRoll.total, damageType, target, damageRoll, { flavor: `(${CONFIG.DND5E.damageTypes[damageType]})`, itemCardId: lastArg.itemCardId, itemData: itemD, useOther: false });\nlet damageBonusMacro = getProperty(actorD.data.flags, `${game.system.id}.DamageBonusMacro`);\nif (damageBonusMacro) {\n  await damageWorkflow.rollBonusDamage(damageBonusMacro);\n} else {\n  await damageWorkflow;\n}","folder":null,"sort":0,"permission":{"default":0},"flags":{}}}},"midi-qol":{"onUseMacroName":"[postActiveEffects]ItemMacro","effectActivation":false},"autoanimations":{"killAnim":false,"below":false,"override":false,"targetToken":{"enable":false},"sourceToken":{"enable":false},"allSounds":{},"autoOverride":{"enable":false},"version":1},"core":{"sourceId":"Item.ckyYhsA1hNLbxTyu"},"exportSource":{"world":"darklands","system":"dnd5e","coreVersion":"0.8.9","systemVersion":"1.5.6"}},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":1669440918464,"modifiedTime":1669440918464,"lastModifiedBy":"T4cu5jv0VXcrhb1w"},"_id":"bv8K7s57EanQSbBs","folder":null,"sort":0,"ownership":{"default":0,"T4cu5jv0VXcrhb1w":3}}
{"name":"Maledizione della Lama del Sortilegio","type":"feat","img":"icons/magic/death/projectile-skull-flaming-green.webp","system":{"description":{"value":"<h3><span style=\"color:#9F000F\"><strong>Maledizione della Lama del Sortilegio</strong></span></h3><p>A partire dal 1 ° livello, un warlock ottiene la capacità di scagliare una maledizione funesta su qualcuno. Con un'azione bonus, il warlock sceglie una creatura situata entro 9 metri da lui e che egli sia in grado di vedere. Il bersaglio è maledetto per 1 minuto. La maledizione termina in anticipo se il bersaglio muore, il warlock muore o il warlock diventa incapacitato. Finché la maledizione non termina, il warlock ottiene i benefici seguenti:</p><ul><li>Il warlock ottiene un bonus pari al suo bonus di competenza da applicare ai tiri per i danni contro il bersaglio maledetto.</li><li>Ogni tiro per colpire che il warlock effettua contro il bersaglio maledetto è un colpo critico con un risultato di 19 o 20 al tiro del d20.</li><li>Se il bersaglio maledetto muore, il warlock recupera un ammontare di punti ferita pari al suo livello da warlock + il suo modificatore di Carisma (fino a un minimo di 1 punto ferita).</li></ul><p>Il warlock non può usare di nuovo questo privilegio finché non completa un riposo breve o lungo.</p>","chat":"","unidentified":""},"source":"","activation":{"type":"action","cost":1,"condition":""},"duration":{"value":null,"units":""},"target":{"value":1,"width":null,"units":"","type":"creature"},"range":{"value":30,"long":null,"units":"ft"},"uses":{"value":0,"max":"0","per":"","recovery":""},"consume":{"type":"","target":"","amount":null},"ability":"","actionType":"util","attackBonus":0,"chatFlavor":"","critical":{"threshold":null,"damage":null},"damage":{"parts":[],"versatile":""},"formula":"","save":{"ability":"","dc":null,"scaling":"spell"},"requirements":"","recharge":{"value":null,"charged":false},"attunement":null},"effects":[],"ownership":{"default":0,"T4cu5jv0VXcrhb1w":3,"cerf0tYYbyMdOK0R":3},"flags":{"itemacro":{"macro":{"data":{"_id":null,"name":"Hexblade's Curse","type":"script","author":"Tyd5yiqWrRZMvG30","img":"icons/svg/dice-target.svg","scope":"global","command":"async function wait(ms) { return new Promise(resolve => { setTimeout(resolve, ms); }); }\nconst lastArg = args[args.length - 1];\nif (args[0].tag === \"OnUse\") {\n    const target = canvas.tokens.get(lastArg.targets[0].id);\n    const tokenD = canvas.tokens.get(lastArg.tokenId);\n    const itemD = lastArg.item;\n    const game_round = game.combat ? game.combat.round : 1;\n    if (target.actor.effects.find(i => i.data.label === \"Hexblade Life Tap\")) return ui.notifications.warn(`Target is already under the effects of ${itemD.name}.`);\n    return await new Promise(async (resolve) => {\n        let stepA = await bonusDamage(target, itemD, tokenD, game_round);\n        let stepB = await lifeTap(target, itemD, tokenD, game_round);\n        resolve(stepA, stepB);        \n    });\n}\n\nasync function bonusDamage(target, itemD, tokenD, game_round) {\n    const effectData = {\n        changes: [\n            { key: \"flags.midi-qol.hexbladeMark\", mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE, value: target.id, priority: 20 },\n            { key: \"flags.dnd5e.DamageBonusMacro\", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: `ItemMacro.${itemD.name}`, priority: 20 },\n            { key: \"macro.itemMacro\", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: `ItemMacro.${itemD.name}`, priority: 20 }\n        ],\n        origin: lastArg.uuid,\n        disabled: false,\n        flags: { dae: { itemData: itemD, specialDuration: [\"zeroHP\"] } },\n        duration: { rounds: 10, startRound: game_round, startTime: game.time.worldTime },\n        icon: \"systems/dnd5e/icons/skills/affliction_04.jpg\",\n        label: `Hexblade Bonus Damage`\n    }\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: tokenD.actor.uuid, effects: [effectData] });\n}\n\nasync function lifeTap(target, itemD, tokenD, game_round) {\n    let effect = await tokenD.actor.effects.find(i => i.data.label === \"Hexblade Bonus Damage\");\n    let effectData = {\n        label: `Hexblade Life Tap`,\n        icon: \"systems/dnd5e/icons/skills/affliction_01.jpg\",\n        origin: lastArg.uuid,\n        disabled: false,\n        duration: { rounds: 10, startRound: game_round, startTime: game.time.worldTime },\n        flags: {\n            \"dae\": { tokenId: tokenD.id, itemData: itemD }\n        },\n        changes: [\n            { key: \"macro.execute\", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: \"HexSupport\", priority: 20 },\n            { key: \"flags.midi-qol.hexEffect\", mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE, value: \"Hexblade\", priority: 20 },\n            { key: `flags.dae.deleteUuid`, mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE, value: effect.uuid, priority: 20 }\n        ]\n    };\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: target.actor.uuid, effects: [effectData] });\n}\n\n// Dropped Critical Only Dice are doubled\nif (args[0].tag === \"DamageBonus\") {\n    const target = canvas.tokens.get(lastArg.targets[0].id);\n    const tokenD = canvas.tokens.get(lastArg.tokenId);\n    if (![\"ak\"].some(i=> (lastArg.item.data.actionType).toLowerCase().includes(i))) return {};\n    if (target.id !== getProperty(tokenD.actor.data.flags, \"midi-qol.hexbladeMark\")) return {};\n    let damageType = lastArg.damageDetail[0].type;\n    let damageNumber = await new game.dnd5e.dice.DamageRoll(`@prof[${damageType}]`, tokenD.actor.getRollData(), { critical: false }).evaluate({ async: true });\n    return { damageRoll: damageNumber.formula, flavor: `(Hexblade Damage (${damageType}))`, damageList: lastArg.damageList };\n}\n\nif (args[0] === \"on\") {\n    const tokenD = canvas.tokens.get(lastArg.tokenId);\n    let hookCheck = DAE.getFlag(tokenD.actor, \"HexbladeCrit\");\n    if (hookCheck) {\n        Hooks.off(\"midi-qol.preambleComplete\", hookId);\n        await DAE.unsetFlag(tokenD.actor, \"HexbladeCrit\");\n        let hookId = Hooks.on(\"midi-qol.preambleComplete\", criticalApply);\n        await DAE.setFlag(tokenD.actor, \"HexbladeCrit\", hookId);\n    } else {\n    let hookId = Hooks.on(\"midi-qol.preambleComplete\", criticalApply);\n    await DAE.setFlag(tokenD.actor, \"HexbladeCrit\", hookId);\n    }\n}\n\nasync function criticalApply(workflow) {\n    let itemD = await fromUuid(workflow.uuid);\n    let attackList = await workflow.targets.entries().next().value.map(i => i.id);\n    let targetId = getProperty(workflow.actor.data.flags, \"midi-qol.hexbladeMark\");\n    let targetFound = attackList.reduce((list, item) => {\n        list = item === targetId ? true : false;\n        return list;\n    }, false);\n    if (![\"ak\"].some(i => (itemD.data.data.actionType).toLowerCase().includes(i))) return {};\n    if (targetFound) {\n        let flagWeaponCritical = await getProperty(workflow.actor.data.flags, \"dnd5e.weaponCriticalThreshold\") ?? 19;\n        let flagSpellCritical = await getProperty(workflow.actor.data.flags, \"dnd5e.spellCriticalThreshold\") ?? 19;\n        let itemCritical = itemD.getChatData().critical.threshold ?? 19;\n        let weaponCritical = Math.min(itemCritical, flagWeaponCritical);\n        let spellCritical = flagSpellCritical;\n        let effect = workflow.actor.effects.find(i => i.data.label === `Hexblade Critical`);\n        let effectData = {\n            label: `Hexblade Critical`,\n            icon: \"systems/dnd5e/icons/skills/affliction_01.jpg\",\n            origin: \"\",\n            disabled: false,\n            flags: { dae: { itemData: itemD.data, specialDuration: [\"1Attack:mwak\", \"1Attack:rwak\", \"1Attack:msak\", \"1Attack:msak\", \"1Attack:rsak\", \"turnEnd\", \"zeroHP\"] } },\n            changes: [\n                { key: \"flags.dnd5e.weaponCriticalThreshold\", mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE, value: weaponCritical, priority: 20 },\n                { key: \"flags.dnd5e.spellCriticalThreshold\", mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE, value: spellCritical, priority: 20 }\n            ]\n        };\n        if (!effect) await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: workflow.actor.uuid, effects: [effectData] });\n    }\n}\n\nif (args[0] === \"off\") {\n    const tokenD = canvas.tokens.get(lastArg.tokenId);\n    let hookId = DAE.getFlag(tokenD.actor, \"HexbladeCrit\");\n    if (hookId) {\n        Hooks.off(\"midi-qol.preambleComplete\", hookId);\n        await DAE.unsetFlag(tokenD.actor, \"HexbladeCrit\");\n    }\n}","folder":null,"sort":0,"permission":{"default":0},"flags":{}},"_id":null,"name":"Hexblade's Curse","type":"script","author":"Tyd5yiqWrRZMvG30","img":"icons/svg/dice-target.svg","scope":"global","command":"async function wait(ms) { return new Promise(resolve => { setTimeout(resolve, ms); }); }\nconst lastArg = args[args.length - 1];\nconst version = Math.floor(game.version);\n\nif (args[0].tag === \"OnUse\") {\n    const target = canvas.tokens.get(lastArg.targets[0].id);\n    const tokenD = canvas.tokens.get(lastArg.tokenId);\n    const itemD = lastArg.item;\n    console.log(`%c${itemD.name} => ### Starting ###`, `background: #222; color: #bada55`);\n    const game_round = game.combat ? game.combat.round : 1;\n    console.log(`%c${itemD.name} => Target: ${target.actor.name}`, `background: #222; color: #bada55`);\n    if (target.actor.effects.find(i => (version > 9 ? i.label === \"Hexblade Life Tap\" : i.data?.label) === \"Hexblade Life Tap\")) return ui.notifications.warn(`Target is already under the effects of ${itemD.name}.`);\n    return await new Promise(async (resolve) => {\n        let stepA = await bonusDamage(target, itemD, tokenD, game_round);\n        let stepB = await lifeTap(target, itemD, tokenD, game_round);\n        resolve(stepA, stepB);\n    });\n}\n\nasync function bonusDamage(target, itemD, tokenD, game_round) {\n    console.log(`%c${itemD.name} => Bonus Damage Applying on: ${tokenD.name}`, `background: #222; color: #bada55`);\n    let effect = await tokenD.actor.effects.find(i => (version > 9 ? i.label : i.data?.label) === `Hexblade Bonus Damage`);\n    const effectData = {\n        changes: [\n            { key: \"flags.midi-qol.hexbladeMark\", mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE, value: target.id, priority: 20 },\n            { key: \"flags.dnd5e.DamageBonusMacro\", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: `ItemMacro.${itemD.name}`, priority: 20 },\n            { key: \"macro.itemMacro\", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: `ItemMacro.${itemD.name}`, priority: 20 }\n        ],\n        origin: lastArg.uuid,\n        disabled: false,\n        transfer: false,\n        flags: { dae: { itemData: itemD, specialDuration: [\"zeroHP\"] } },\n        duration: { rounds: 10, startRound: game_round, startTime: game.time.worldTime },\n        icon: itemD.img,\n        label: `Hexblade Bonus Damage`\n    }\n    if (!effect) await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: tokenD.actor.uuid, effects: [effectData] });\n    return;\n}\n\nasync function lifeTap(target, itemD, tokenD, game_round) {\n    console.log(`%c${itemD.name} => Life Tap Applying: ${target.actor.name}`, `background: #222; color: #bada55`);\n    let effect = await target.actor.effects.find(i => (version > 9 ? i.label : i.data?.label) === `Hexblade Life Tap`);\n    let damageEffect = await tokenD.actor.effects.find(i => (version > 9 ? i.label : i.data?.label) === \"Hexblade Bonus Damage\");\n    let effectData = {\n        label: `Hexblade Life Tap`,\n        icon: \"icons/magic/death/skull-horned-goat-pentagram-red.webp\",\n        origin: lastArg.uuid,\n        disabled: false,\n        transfer: false,\n        duration: { rounds: 10, startRound: game_round, startTime: game.time.worldTime },\n        flags: {\n            \"dae\": { tokenId: tokenD.id, itemData: itemD }\n        },\n        changes: [\n            { key: \"macro.execute\", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: \"HexSupport\", priority: 20 },\n            { key: \"flags.midi-qol.hexEffect.caster\", mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE, value: tokenD.id, priority: 20 },\n            { key: \"flags.midi-qol.hexEffect\", mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE, value: \"Hexblade\", priority: 20 },\n            { key: `flags.dae.deleteUuid`, mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE, value: damageEffect.uuid, priority: 20 }\n        ]\n    };\n    if (!effect) await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: target.actor.uuid, effects: [effectData] });\n    return;\n}\n\n// Dropped Critical Only Dice are doubled\nif (args[0].tag === \"DamageBonus\") {    \n    const target = canvas.tokens.get(lastArg.targets[0].id);\n    const actorD = canvas.tokens.get(lastArg.tokenId).actor;\n    const itemD = await fromUuid(lastArg.uuid);\n    const itemData = await itemD.getChatData();\n    console.log(`%cHexBlade => Checking for Valid Attack Roll`, `background: #222; color: #bada55`);\n    if (![\"ak\"].some(i => (itemData.actionType).toLowerCase().includes(i))) return console.log(`%cHexBlade => ${itemD.name} Invalid Attack Roll`, `background: #222; color: #bada55`);\n    console.log(`%cHexBlade => ${itemD.name} Valid Attack Roll`, `background: #222; color: #bada55`);\n    let checkId = getProperty((version > 9 ? actorD.flags : actorD.data?.flags), \"midi-qol.hexbladeMark\");\n    if (target.id !== checkId) return console.log(`%cHexBlade => ${target.id} != ${checkId}: No Match`, `background: #222; color: #bada55`);\n    console.log(`%cHexBlade => ${target.id} = ${checkId}: Match`, `background: #222; color: #bada55`);\n    let damageType = lastArg.damageDetail[0].type;\n    let damageNumber = await new game.dnd5e.dice.DamageRoll(`@prof[${damageType}]`, actorD.getRollData(), { critical: false }).evaluate({ async: true });\n    return { damageRoll: damageNumber.formula, flavor: `(Hexblade Damage (${damageType}))`, damageList: lastArg.damageList };\n}\n\nif (args[0] === \"on\") {\n    const actorD = canvas.tokens.get(lastArg.tokenId).actor;\n    console.log(`%cHexBlade => Setting Up Critical on: ${actorD.name}`, `background: #222; color: #bada55`);\n    let hookCheck = DAE.getFlag(actorD, \"HexbladeCrit\");\n    if (hookCheck) {\n        console.log(`%cHexBlade => Found old hooks, clean up`, `background: #222; color: #bada55`);\n        Hooks.off(\"midi-qol.preambleComplete\", hookId);\n        await DAE.unsetFlag(actorD, \"HexbladeCrit\");\n    }\n    console.log(`%cHexBlade => Attaching Critical on`, `background: #222; color: #bada55`);\n        let hookId = Hooks.on(\"midi-qol.preambleComplete\", criticalApply);\n        await DAE.setFlag(actorD, \"HexbladeCrit\", hookId);\n}\n\nasync function criticalApply(workflow) {\n    let casterId = getProperty((version > 9 ? workflow.actor.flags : workflow.actor.data.flags), \"midi-qol.hexEffect.caster\");\n    if (workflow.tokenId != casterId) return {};    \n    if (workflow.hitTargets.length === 0) return {};\n    let itemD = await fromUuid(workflow.uuid);\n    let itemData = await itemD.getChatData();\n    let attackList = await workflow.targets.entries().next().value.map(i => i.id);\n    let targetId = getProperty((version > 9 ? workflow.actor.flags : workflow.actor.data?.flags), \"midi-qol.hexbladeMark\");\n    let targetFound = attackList.reduce((list, item) => {\n        list = item === targetId ? true : false;\n        return list;\n    }, false);\n    if (![\"ak\"].some(i => (itemData.actionType).toLowerCase().includes(i))) return console.log(`%cHexBlade => Not an Attack Roll`, `background: #222; color: #bada55`);\n    console.log(`%cHexBlade => Critical Roll Attack Found`, `background: #222; color: #bada55`);\n    if (targetFound) {\n        console.log(`%cHexBlade => Critical Effect Added`, `background: #222; color: #bada55`);\n        let flagWeaponCritical = await getProperty((version > 9 ? workflow.actor.flags : workflow.actor.data?.flags), \"dnd5e.weaponCriticalThreshold\") ?? 19;\n        let flagSpellCritical = await getProperty((version > 9 ? workflow.actor.flags : workflow.actor.data?.flags), \"dnd5e.spellCriticalThreshold\") ?? 19;\n        let itemCritical = itemData.critical.threshold ?? 19;\n        let weaponCritical = Math.min(itemCritical, flagWeaponCritical);\n        let spellCritical = flagSpellCritical;\n        let effect = workflow.actor.effects.find(i => (version > 9 ? i.label : i.data?.label) === `Hexblade Critical`);\n        let effectData = {\n            label: `Hexblade Critical`,\n            icon: \"systems/dnd5e/icons/skills/affliction_01.jpg\",\n            origin: \"\",\n            disabled: false,\n            transfer: false,\n            flags: { dae: { itemData: itemData, specialDuration: [\"1Attack:mwak\", \"1Attack:rwak\", \"1Attack:msak\", \"1Attack:msak\", \"1Attack:rsak\", \"turnEnd\", \"zeroHP\"] } },\n            changes: [\n                { key: \"flags.dnd5e.weaponCriticalThreshold\", mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE, value: weaponCritical, priority: 20 },\n                { key: \"flags.dnd5e.spellCriticalThreshold\", mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE, value: spellCritical, priority: 20 }\n            ]\n        };        \n        if (!effect) {\n            console.log(`%cHexBlade => Critical Effect Added`, `background: #222; color: #bada55`);\n            await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: workflow.actor.uuid, effects: [effectData] });\n    }\n        return;\n    }\n}\n\nif (args[0] === \"off\") {\n    console.log(`%cHexBlade => Shuting down`, `background: #222; color: #bada55`);\n    const actorD = canvas.tokens.get(lastArg.tokenId).actor;\n    let hookId = DAE.getFlag(actorD, \"HexbladeCrit\");\n    if (hookId) {\n        console.log(`%cHexBlade => Unhooking`, `background: #222; color: #bada55`);\n        Hooks.off(\"midi-qol.preambleComplete\", hookId);\n        await DAE.unsetFlag(actorD, \"HexbladeCrit\");\n    }\n}","folder":null,"sort":0,"permission":{"default":0},"flags":{}}},"magicitems":{"enabled":false,"equipped":false,"attuned":false,"charges":"0","chargeType":"c1","destroy":false,"destroyFlavorText":"reaches 0 charges: it crumbles into ashes and is destroyed.","rechargeable":false,"recharge":"0","rechargeType":"t1","rechargeUnit":"r1","sorting":"l"},"core":{"sourceId":"Item.Zb2dFfCNTVqd8A8q"},"midi-qol":{"onUseMacroName":"[postActiveEffects]ItemMacro","effectActivation":false},"exportSource":{"world":"darklands","system":"dnd5e","coreVersion":"9.280","systemVersion":"1.6.3"},"midiProperties":{"nodam":false,"fulldam":false,"halfdam":false,"rollOther":false,"critOther":false,"magicdam":false,"magiceffect":false,"concentration":false,"toggleEffect":false,"ignoreTotalCover":false}},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":1669441878213,"modifiedTime":1669595418928,"lastModifiedBy":"cerf0tYYbyMdOK0R"},"folder":null,"sort":0,"_id":"ceotz0LuRjdsHBJU"}
{"name":"Harness Divine Power","type":"feat","img":"icons/environment/settlement/gazebo.webp","system":{"description":{"value":"<p><em>2nd-level cleric feature</em><br />You can expend a use of your Channel Divinity to fuel your spells. As a bonus action, you touch your holy symbol, utter a prayer, and regain one expended spell slot, the level of which can be no higher than half your proficiency bonus (rounded up). The number of times you can use this feature is based on the level you’ve reached in this class: 2nd level, once; 6th level, twice; and 18th level, thrice. You regain all expended uses when you finish a long rest.</p>\n\n","chat":"","unidentified":""},"source":"Tasha’s Cauldron of Everything","activation":{"type":"bonus","cost":1,"condition":""},"duration":{"value":null,"units":""},"target":{"value":null,"width":null,"units":"","type":"self"},"range":{"value":null,"long":null,"units":"self"},"uses":{"value":0,"max":"0","per":"","recovery":""},"consume":{"type":"","target":"","amount":null},"ability":"","actionType":"util","attackBonus":0,"chatFlavor":"","critical":{"threshold":null,"damage":null},"damage":{"parts":[],"versatile":""},"formula":"","save":{"ability":"","dc":null,"scaling":"spell"},"requirements":"Cleric","recharge":{"value":null,"charged":false}},"effects":[{"_id":"mogsjbXaqQiiJaPS","changes":[{"key":"system.attributes.movement.all","mode":2,"value":"0","priority":20}],"disabled":false,"duration":{"startTime":null,"seconds":null,"combat":null,"rounds":null,"turns":null,"startRound":null,"startTurn":null},"icon":"icons/environment/settlement/gazebo.webp","label":"Harness Divine Power","transfer":false,"flags":{"dae":{"stackable":"none","macroRepeat":"none","specialDuration":[],"transfer":false},"dnd5e-helpers":{"rest-effect":"Ignore"},"ActiveAuras":{"isAura":false,"aura":"None","radius":null,"alignment":"","type":"","ignoreSelf":false,"height":false,"hidden":false,"hostile":false,"onlyOnce":false}},"tint":null,"origin":null}],"flags":{"ddbimporter":{"id":3021050,"data":{"id":3021050,"definitionKey":"class-feature:3021050","entityTypeId":12168134,"displayOrder":2,"name":"Harness Divine Power","description":"<p><em>2nd-level cleric feature</em><br />You can expend a use of your Channel Divinity to fuel your spells. As a bonus action, you touch your holy symbol, utter a prayer, and regain one expended spell slot, the level of which can be no higher than half your proficiency bonus (rounded up). The number of times you can use this feature is based on the level you’ve reached in this class: 2nd level, once; 6th level, twice; and 18th level, thrice. You regain all expended uses when you finish a long rest.</p>","snippet":"You can expend a use of your <em>Channel Divinity</em> to fuel your spells. As a bonus action, you regain one expended spell slot of up to level {{(proficiency/2)@roundup#unsigned}}. You can use this feature {{scalevalue#unsigned}} times. You regain all expended uses when you finish a long rest.","activation":null,"multiClassDescription":"","requiredLevel":2,"isSubClassFeature":false,"limitedUse":[{"level":null,"uses":1}],"hideInBuilder":false,"hideInSheet":false,"sourceId":67,"sourcePageNumber":30,"creatureRules":[],"levelScales":[{"id":388377,"level":2,"description":"1 use","dice":{"diceCount":null,"diceValue":null,"diceMultiplier":null,"fixedValue":null,"diceString":null},"fixedValue":1},{"id":388378,"level":6,"description":"2 uses","dice":{"diceCount":null,"diceValue":null,"diceMultiplier":null,"fixedValue":null,"diceString":null},"fixedValue":2},{"id":388379,"level":18,"description":"3 uses","dice":{"diceCount":null,"diceValue":null,"diceMultiplier":null,"fixedValue":null,"diceString":null},"fixedValue":3}],"infusionRules":[],"spellListIds":[],"classId":2,"featureType":2,"sources":[{"sourceId":67,"pageNumber":null,"sourceType":1}],"affectedFeatureDefinitionKeys":[],"entityType":"class-feature","entityID":3021050},"featureId":3021050,"requiredLevel":2,"class":"Cleric","classId":2,"subClass":""},"core":{"sourceId":"Compendium.world.ddb-darklands-class-features.zEp4nKWEsK6c2ow2"},"magicitems":{"enabled":false,"equipped":false,"attuned":false,"charges":"0","chargeType":"c1","destroy":false,"destroyFlavorText":"reaches 0 charges: it crumbles into ashes and is destroyed.","rechargeable":false,"recharge":"0","rechargeType":"t1","rechargeUnit":"r1","sorting":"l"},"midi-qol":{"onUseMacroName":"[postActiveEffects]ItemMacro","effectActivation":false},"itemacro":{"macro":{"data":{"_id":null,"name":"Harness Divine Power","type":"script","author":"Tyd5yiqWrRZMvG30","img":"icons/svg/dice-target.svg","scope":"global","command":"// Use Midi-qol + Item Macro. That will trigger resouce consumption.\n\nlet actorD = canvas.tokens.get(args[0].tokenId).actor;\nif (actorD.data.data.spells.spell1.max === 0) return ui.notifications.error(`No spell slots found on ${actorD.name}`);\nlet itemD = args[0].item;\nlet rollData = await actorD.getRollData();\nlet prof = Math.ceil(rollData.prof / 2);\nlet inputText = \"\";\nif (hasAvailableSlot(actor)) {\n    // Get options for available slots\n    for (let i = 1; i <= prof; i++) {\n        let chosenSpellSlots = getSpellSlots(actorD, i);\n        let minSlots = chosenSpellSlots.value;\n        let maxSlots = chosenSpellSlots.max;\n        if (minSlots != maxSlots) {\n            inputText += `<div class=\"form-group\"><label for=\"spell${i}\">Spell Slot Level ${i} [${minSlots}/${maxSlots}]</label><input id=\"spell${i}\" name=\"spellSlot\" value=\"${i}\" type=\"radio\"></div>`;\n        }\n    }\n    new Dialog({\n        title: itemD.name,\n        content: `<form><p>Choose 1 spell slot to restore</p><hr>${inputText}</form>`,\n        buttons: {\n            recover: {\n                icon: '<i class=\"fas fa-check\"></i>',\n                label: \"Recover\",\n                callback: async (html) => {\n                    let selected_slot = html.find('input[name=\"spellSlot\"]:checked');\n                    let slot = \"\";\n                    let num = \"\";\n                    for (let i = 0; i < selected_slot.length; i++) {\n                        slot = selected_slot[i].id;\n                        num = selected_slot[i].value;\n                    }\n                    if(slot === \"\") return ui.notifications.warn(`The ability fails, no spell slot was selected`);\n                    spell_refund(actorD, slot);\n                    let roll_results = `<div>Regains 1 spell slot, Level ${num}.</div>`;\n                    const chatMessage = game.messages.get(args[0].itemCardId);\n                    let content = duplicate(chatMessage.data.content);\n                    const searchString = /<div class=\"midi-qol-saves-display\">[\\s\\S]*<div class=\"end-midi-qol-saves-display\">/g;\n                    const replaceString = `<div class=\"midi-qol-saves-display\"><div class=\"end-midi-qol-saves-display\">${roll_results}`;\n                    content = content.replace(searchString, replaceString);\n                    chatMessage.update({ content: content });\n                }\n            }\n        }\n    }).render(true);\n} else {\n    return ui.notifications.warn(`You aren't missing any spell slots.`);\n}\n\nasync function spell_refund(actorD, slot, num) {\n    let actor_data = duplicate(actorD.data._source);\n    actor_data.data.spells[`${slot}`].value = actor_data.data.spells[`${slot}`].value + 1;\n    await actorD.update(actor_data);\n}\n\nfunction getSpellSlots(actorD, level) {\n    return actorD.data.data.spells[`spell${level}`];\n}\n\nfunction hasAvailableSlot(actorD) {\n    for (let slot in actorD.data.data.spells) {\n        if (actorD.data.data.spells[slot].value < actorD.data.data.spells[slot].max) {\n            return true;\n        }\n    }\n    return false;\n}","folder":null,"sort":0,"permission":{"default":0},"flags":{}}}},"exportSource":{"world":"darklands","system":"dnd5e","coreVersion":"0.8.9","systemVersion":"1.5.6"},"midiProperties":{"nodam":false,"fulldam":false,"halfdam":false,"rollOther":false,"critOther":false,"magicdam":false,"magiceffect":false,"concentration":false,"toggleEffect":false}},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":1669440918463,"modifiedTime":1669440918463,"lastModifiedBy":"T4cu5jv0VXcrhb1w"},"_id":"dWm69Kih0sQk4KA3","folder":null,"sort":0,"ownership":{"default":0,"T4cu5jv0VXcrhb1w":3}}
{"name":"Vampire Bite","type":"weapon","img":"icons/creatures/abilities/fangs-teeth-bite.webp","system":{"description":{"value":"<p><em><strong></strong> Melee Weapon Attack:</em> +9 to hit, reach 5 ft., one willing creature, or a creature that is grappled by the vampire, incapacitated, or restrained. <em>Hit:</em> 7 (1d6 + 4) piercing damage plus 10 (3d6) necrotic damage. The target’s hit point maximum is reduced by an amount equal to the necrotic damage taken, and the vampire regains hit points equal to that amount. The reduction lasts until the target finishes a long rest. The target dies if this effect reduces its hit point maximum to 0. A humanoid slain in this way and then buried in the ground rises the following night as a vampire spawn under the vampire’s control.</p>","chat":"","unidentified":""},"source":"Basic Rules pg 352","quantity":1,"weight":0,"price":0,"attunement":0,"equipped":true,"rarity":"","identified":true,"activation":{"type":"special","cost":1,"condition":""},"duration":{"value":1,"units":"day"},"target":{"value":null,"width":null,"units":"","type":""},"range":{"value":5,"long":null,"units":"ft"},"uses":{"value":0,"max":"0","per":"","recovery":""},"consume":{"type":"","target":"","amount":null},"ability":"str","actionType":"mwak","attackBonus":"0","chatFlavor":"","critical":{"threshold":null,"damage":""},"damage":{"parts":[["1d6 + @mod","piercing"],["3d6","necrotic"]],"versatile":""},"formula":"","save":{"ability":"","dc":null,"scaling":"flat"},"armor":{"value":10},"hp":{"value":0,"max":0,"dt":null,"conditions":""},"weaponType":"natural","baseItem":"","properties":{"amm":false,"fin":false,"fir":false,"foc":false,"hvy":false,"lgt":false,"lod":false,"rch":false,"rel":false,"ret":false,"spc":false,"thr":false,"two":false,"ver":false,"ada":false,"mgc":false,"sil":false,"nodam":false,"fulldam":false,"halfdam":false,"critOther":false},"proficient":true,"recharge":{"value":null,"charged":null}},"effects":[],"flags":{"monsterMunch":{"titleHTML":"<strong>Bite. (Bat or Vampire Form Only).</strong>","fullName":"Bite. (Bat or Vampire Form Only)."},"midi-qol":{"criticalThreshold":"20","onUseMacroName":"[postActiveEffects]ItemMacro","effectActivation":false,"fumbleThreshold":null},"magicitems":{"enabled":false,"equipped":false,"attuned":false,"charges":"0","chargeType":"c1","destroy":false,"destroyFlavorText":"reaches 0 charges: it crumbles into ashes and is destroyed.","rechargeable":false,"recharge":"0","rechargeType":"t1","rechargeUnit":"r1","sorting":"l"},"core":{"sourceId":"Item.8sZeHXEdRHCVbXlB"},"itemacro":{"macro":{"data":{"_id":null,"name":"Vampire Bite","type":"script","author":"Tyd5yiqWrRZMvG30","img":"icons/svg/dice-target.svg","scope":"global","command":"async function wait(ms) { return new Promise(resolve => { setTimeout(resolve, ms); }); }\nconst lastArg = args[args.length - 1];\nif(lastArg.hitTargets.length === 0) return {};\nlet tokenD = canvas.tokens.get(lastArg.tokenId);\nlet target = canvas.tokens.get(lastArg.hitTargets[0].id);\nlet itemD = await fromUuid(lastArg.itemUuid);\nlet gameRound = game.combat ? game.combat.round : 0;\nlet healType = \"healing\";\nlet damageType = \"necrotic\";\nlet damageTotal = lastArg.damageDetail.find(i=> i.type === damageType);\nif(!damageTotal) return ui.notifications.error(\"Deal damage first\");\nlet healAmount = Math.clamped(damageTotal.damage, 0, tokenD.actor.data.data.attributes.hp.max - tokenD.actor.data.data.attributes.hp.value);\nawait MidiQOL.applyTokenDamage([{damage: healAmount, type: healType}], healAmount, new Set([tokenD]), itemD, new Set());\nlet effectData = {\n    label: itemD.name,\n    icon: itemD.img,\n    flags: { dae: { itemData: itemD.data, stackable: true, macroRepeat: \"none\", specialDuration: [\"longRest\"] } },\n    origin: lastArg.uuid,\n    disabled: false,\n    duration: {seconds: 86400, hours: 24, startRound: gameRound, startTime: game.time.worldTime },\n    changes: [{ key: \"data.attributes.hp.max\", mode: 2, value: -damageTotal.damage, priority: 20 }]\n};\nawait MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: target.actor.uuid, effects: [effectData] });\nlet healMessage = `<div class=\"midi-qol-flex-container\"><div class=\"midi-qol-target-npc midi-qol-target-name\" id=\"${target.id}\">hits ${target.name} <span style=\"color:red\">max hp -${damageTotal.damage}</span></div><img src=\"${target.data.img}\" width=\"30\" height=\"30\" style=\"border:0px\"></div><div class=\"midi-qol-flex-container\"><div class=\"midi-qol-target-npc midi-qol-target-name\" id=\"${tokenD.id}\">heals ${tokenD.name} <span style=\"color:green\">+${healAmount}</span></div><img src=\"${tokenD.data.img}\" width=\"30\" height=\"30\" style=\"border:0px\"></div>`;\n//await wait(400);\nlet chatMessage = await game.messages.get(args[0].itemCardId);\nlet content = await duplicate(chatMessage.data.content);\nlet searchString = /<div class=\"midi-qol-hits-display\">[\\s\\S]*<div class=\"end-midi-qol-hits-display\">/g;\nlet replaceString = `<div class=\"midi-qol-hits-display\"><div class=\"end-midi-qol-hits-display\">${healMessage}`;\ncontent = await content.replace(searchString, replaceString);\nawait chatMessage.update({ content: content });","folder":null,"sort":0,"permission":{"default":0},"flags":{}}}},"favtab":{"isFavorite":true},"exportSource":{"world":"darklands","system":"dnd5e","coreVersion":"0.8.9","systemVersion":"1.5.3"},"midiProperties":{"nodam":false,"fulldam":false,"halfdam":false,"rollOther":false,"critOther":false,"magicdam":false,"magiceffect":false,"concentration":false,"toggleEffect":false}},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":1669440918467,"modifiedTime":1669440918467,"lastModifiedBy":"T4cu5jv0VXcrhb1w"},"_id":"dkrkyACAdx1LFQPr","folder":null,"sort":0,"ownership":{"default":0,"T4cu5jv0VXcrhb1w":3}}
{"name":"Wild Shape","type":"feat","img":"icons/creatures/mammals/elk-moose-marked-green.webp","system":{"description":{"value":"<p class=\"compendium-hr\">Starting at 2nd level, you can use your action to magically assume the shape of a beast that you have seen before. You can use this feature twice. You regain expended uses when you finish a short or long rest.</p>","chat":"","unidentified":""},"source":"","activation":{"type":"bonus","cost":1,"condition":""},"duration":{"value":2,"units":"hour"},"target":{"value":null,"width":null,"units":"","type":"self"},"range":{"value":null,"long":null,"units":"self"},"uses":{"value":2,"max":"2","per":"sr","recovery":""},"consume":{"type":"attribute","target":"","amount":null},"ability":"","actionType":"util","attackBonus":0,"chatFlavor":"","critical":{"threshold":null,"damage":null},"damage":{"parts":[],"versatile":""},"formula":"","save":{"ability":"","dc":null,"scaling":"spell"},"requirements":"Druid","recharge":{"value":null,"charged":false}},"effects":[{"_id":"Tx0SKDQ0cTKx6h4A","changes":[{"key":"macro.itemMacro","mode":0,"value":"@actor","priority":20}],"disabled":false,"duration":{"startTime":null,"seconds":null,"combat":null,"rounds":null,"turns":null,"startRound":null,"startTurn":null},"icon":"icons/creatures/mammals/elk-moose-marked-green.webp","label":"Wild Shape","transfer":false,"flags":{"dae":{"stackable":"none","macroRepeat":"none","specialDuration":[],"transfer":false},"dnd5e-helpers":{"rest-effect":"Ignore"},"ActiveAuras":{"isAura":false,"aura":"None","radius":null,"alignment":"","type":"","ignoreSelf":false,"height":false,"hidden":false,"hostile":false,"onlyOnce":false}},"tint":null,"origin":null}],"flags":{"ddbimporter":{"id":167,"entityTypeId":"222216831","componentId":167,"componentTypeId":12168134,"dndbeyond":{"levelScale":{"id":12414,"level":4,"description":"[4th] Max CR 1/2 (no flying speed)","dice":null,"fixedValue":null},"levelScales":[{"id":12414,"level":4,"description":"[4th] Max CR 1/2 (no flying speed)","dice":{"diceCount":null,"diceValue":null,"diceMultiplier":null,"fixedValue":null,"diceString":null},"fixedValue":null},{"id":12415,"level":8,"description":"[8th] Max CR 1","dice":{"diceCount":null,"diceValue":null,"diceMultiplier":null,"fixedValue":null,"diceString":null},"fixedValue":null}],"limitedUse":[{"level":null,"uses":1}]},"data":{"id":167,"name":"Wild Shape","prerequisite":null,"description":"<p class=\"compendium-hr\">Starting at 2nd level, you can use your action to magically assume the shape of a beast that you have seen before. You can use this feature twice. You regain expended uses when you finish a short or long rest.</p>\r\n<p class=\"Core-Styles_Core-Body\">Your druid level determines the beasts you can transform into, as shown in the Beast Shapes table. At 2nd level, for example, you can transform into any beast that has a challenge rating of 1/4 or lower that doesn’t have a flying or swimming speed.</p>\r\n<h5>Beast Shapes</h5>\r\n<table>\r\n<thead>\r\n<tr class=\"Table _idGenTableRowColumn-12\">\r\n<th class=\"Table Table-Header\">\r\n<p class=\"Table-Styles_Header--for-Table-Cell-Style- ParaOverride-3\">Level</p>\r\n</th>\r\n<th class=\"Table Table-Header _idGenCellOverride-1\">\r\n<p class=\"Table-Styles_Header--for-Table-Cell-Style- ParaOverride-3\">Max CR</p>\r\n</th>\r\n<th class=\"Table Table-Header _idGenCellOverride-1\">\r\n<p class=\"Table-Styles_Header--for-Table-Cell-Style-\">Limitations</p>\r\n</th>\r\n<th class=\"Table Table-Header _idGenCellOverride-1\">\r\n<p class=\"Table-Styles_Header--for-Table-Cell-Style-\">Example</p>\r\n</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"Table _idGenTableRowColumn-4\">\r\n<td class=\"Table Table-Body _idGenCellOverride-2\">\r\n<p class=\"Table-Styles_Table-Body--for-Table-Cell-Style- ParaOverride-3\" style=\"text-align: center;\">2nd</p>\r\n</td>\r\n<td class=\"Table Table-Body _idGenCellOverride-2\" style=\"text-align: center;\">\r\n<p class=\"Table-Styles_Table-Body--for-Table-Cell-Style- ParaOverride-3\">1/4</p>\r\n</td>\r\n<td class=\"Table Table-Body _idGenCellOverride-2\" style=\"text-align: center;\">\r\n<p class=\"Table-Styles_Table-Body--for-Table-Cell-Style-\">No flying or swimming speed</p>\r\n</td>\r\n<td class=\"Table Table-Body _idGenCellOverride-2\" style=\"text-align: center;\">\r\n<p class=\"Table-Styles_Table-Body--for-Table-Cell-Style-\">Wolf</p>\r\n</td>\r\n</tr>\r\n<tr class=\"Table _idGenTableRowColumn-5\" style=\"text-align: center;\">\r\n<td class=\"Table Table-Body\">\r\n<p class=\"Table-Styles_Table-Body--for-Table-Cell-Style- ParaOverride-3\">4th</p>\r\n</td>\r\n<td class=\"Table Table-Body\">\r\n<p class=\"Table-Styles_Table-Body--for-Table-Cell-Style- ParaOverride-3\">1/2</p>\r\n</td>\r\n<td class=\"Table Table-Body\">\r\n<p class=\"Table-Styles_Table-Body--for-Table-Cell-Style-\">No flying speed</p>\r\n</td>\r\n<td class=\"Table Table-Body\">\r\n<p class=\"Table-Styles_Table-Body--for-Table-Cell-Style-\" style=\"text-align: center;\">Crocodile</p>\r\n</td>\r\n</tr>\r\n<tr class=\"Table _idGenTableRowColumn-4\">\r\n<td class=\"Table Table-Body\" style=\"text-align: center;\">\r\n<p class=\"Table-Styles_Table-Body--for-Table-Cell-Style- ParaOverride-3\">8th</p>\r\n</td>\r\n<td class=\"Table Table-Body\" style=\"text-align: center;\">\r\n<p class=\"Table-Styles_Table-Body--for-Table-Cell-Style- ParaOverride-3\">1</p>\r\n</td>\r\n<td class=\"Table Table-Body\" style=\"text-align: center;\">\r\n<p class=\"Table-Styles_Table-Body--for-Table-Cell-Style-\">&mdash;</p>\r\n</td>\r\n<td class=\"Table Table-Body\">\r\n<p class=\"Table-Styles_Table-Body--for-Table-Cell-Style-\" style=\"text-align: center;\">Giant eagle</p>\r\n</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p class=\"Core-Styles_Core-Body\" style=\"text-align: left;\"><br />You can stay in a beast shape for a number of hours equal to half your druid level (rounded down). You then revert to your normal form unless you expend another use of this feature. You can revert to your normal form earlier by using a bonus action on your turn. You automatically revert if you fall unconscious, drop to 0 hit points, or die.</p>\r\n<p class=\"Core-Styles_Core-Body-Last--to-apply-extra-space-\">While you are transformed, the following rules apply:</p>\r\n<ul>\r\n<li class=\"Core-Styles_Core-Bulleted\">Your game statistics are replaced by the statistics of the beast, but you retain your alignment, personality, and Intelligence, Wisdom, and Charisma scores. You also retain all of your skill and saving throw proficiencies, in addition to gaining those of the creature. If the creature has the same proficiency as you and the bonus in its stat block is higher than yours, use the creature’s bonus instead of yours. If the creature has any legendary or lair actions, you can’t use them.</li>\r\n<li class=\"Core-Styles_Core-Bulleted\">When you transform, you assume the beast’s hit points and Hit Dice. When you revert to your normal form, you return to the number of hit points you had before you transformed. However, if you revert as a result of dropping to 0 hit points, any excess damage carries over to your normal form. For example, if you take 10 damage in animal form and have only 1 hit point left, you revert and take 9 damage. As long as the excess damage doesn’t reduce your normal form to 0 hit points, you aren’t knocked unconscious.</li>\r\n<li class=\"Core-Styles_Core-Bulleted\">You can’t cast spells, and your ability to speak or take any action that requires hands is limited to the capabilities of your beast form. Transforming doesn’t break your concentration on a spell you’ve already cast, however, or prevent you from taking actions that are part of a spell, such as <span class=\"Serif-Character-Style_Italic-Serif\">call lightning</span>, that you’ve already cast.</li>\r\n<li class=\"Core-Styles_Core-Bulleted\">You retain the benefit of any features from your class, race, or other source and can use them if the new form is physically capable of doing so. However, you can’t use any of your special senses, such as darkvision, unless your new form also has that sense.</li>\r\n<li class=\"Core-Styles_Core-Bulleted-Last\">You choose whether your equipment falls to the ground in your space, merges into your new form, or is worn by it. Worn equipment functions as normal, but the DM decides whether it is practical for the new form to wear a piece of equipment, based on the creature’s shape and size. Your equipment doesn’t change size or shape to match the new form, and any equipment that the new form can’t wear must either fall to the ground or merge with it. Equipment that merges with the form has no effect until you leave the form.</li>\r\n</ul>","requiredLevel":2,"displayOrder":5},"featureId":167,"requiredLevel":2,"prerequisite":null,"class":"Druid","classId":3,"subClass":"","pack":"world.ddb-darklands-class-features","originalItemName":"Wild Shape","replaced":true},"magicitems":{"enabled":false,"equipped":false,"attuned":false,"charges":"0","chargeType":"c1","destroy":false,"destroyFlavorText":"reaches 0 charges: it crumbles into ashes and is destroyed.","rechargeable":false,"recharge":"0","rechargeType":"t1","rechargeUnit":"r1","sorting":"l"},"core":{"sourceId":"Item.GDRnvEUCgN7N5nkW"},"itemacro":{"macro":{"data":{"_id":null,"name":"Wild Shape","type":"script","author":"Tyd5yiqWrRZMvG30","img":"icons/svg/dice-target.svg","scope":"global","command":"async function wait(ms) { return new Promise(resolve => { setTimeout(resolve, ms); }); }\nconst lastArg = args[args.length - 1];\nlet tactor;\nif (lastArg.tokenId) tactor = canvas.tokens.get(lastArg.tokenId).actor;\nelse tactor = game.actors.get(lastArg.actorId);\nconst target = canvas.tokens.get(lastArg.tokenId);\nconst itemD = lastArg.efData.flags.dae.itemData;\nconst folderName = \"Wildshape\";\nconst getFolder = game.folders.getName(folderName).content;\nconst folderContents = getFolder.reduce((acc, target) => acc += `<option value=\"${target.id}\">${target.name} CR: ${target.data.data.details.cr}</option>`\n    , ``);\nconst the_content = `<p>Pick a beast</p><form><div class=\"form-group\"><label for=\"beast\">Beast:</label><select id=\"beast\">${folderContents}</select></div></form>`;\nconst druidItems = tactor.items.filter(i => i.data.type === \"feat\" && i.data.data.activation?.type != \"bonus\" && (i.data.data.requirements.toLowerCase().includes(\"druid\") || i.data.data.requirements.toLowerCase().includes(\"circle\"))).map(i => i.data);\nconst wildshapeHealing = [{\n    \"name\": \"Wild Shape Healing\",\n    \"type\": \"spell\",\n    \"img\": \"icons/magic/life/cross-beam-green.webp\",\n    \"data\": {\n        \"description\": {\n            \"value\": \"<p>While you are transformed by Wild Shape, you can use a bonus action to expend one spell slot to regain 1d8 hit points per level of the spell slot expended.</p>\",\n            \"chat\": \"<p>A creature you touch regains a number of hit points equal to 1d8 + your spellcasting ability modifier. This spell has no effect on undead or constructs.</p>\\n<p><em><strong>At Higher Levels.</strong></em> When you cast this spell using a spell slot of 2nd level or higher, the healing increases by 1d8 for each slot level above 1st.</p>\",\n            \"unidentified\": \"\"\n        },\n        \"activation\": {\n            \"type\": \"action\",\n            \"cost\": 1,\n            \"condition\": \"\"\n        },\n        \"target\": {\n            \"value\": null,\n            \"width\": null,\n            \"units\": \"\",\n            \"type\": \"self\"\n        },\n        \"range\": {\n            \"value\": null,\n            \"long\": null,\n            \"units\": \"self\"\n        },\n        \"actionType\": \"heal\",\n        \"damage\": {\n            \"parts\": [\n                [\n                    \"1d8\",\n                    \"healing\"\n                ]\n            ],\n            \"versatile\": \"\"\n        },\n        \"formula\": \"\",\n        \"save\": {\n            \"ability\": \"\",\n            \"dc\": null,\n            \"scaling\": \"spell\"\n        },\n        \"level\": 1,\n        \"school\": \"evo\",\n        \"components\": {\n            \"value\": \"\",\n            \"vocal\": false,\n            \"somatic\": true,\n            \"material\": false,\n            \"ritual\": false,\n            \"concentration\": false\n        },\n        \"preparation\": {\n            \"mode\": \"prepared\",\n            \"prepared\": true\n        },\n        \"scaling\": {\n            \"mode\": \"level\",\n            \"formula\": \"1\"\n        }\n    },\n    \"effects\": [],\n    \"sort\": 0,\n    \"flags\": {\n        \"favtab\": {\n            \"isFavorite\": true\n        }\n    }\n}];\nconst wildshapeRevert = [{\n    \"name\": \"Wild Shape (Revert)\",\n    \"type\": \"feat\",\n    \"img\": \"icons/creatures/mammals/elk-moose-marked-green.webp\",\n    \"data\": {\n        \"description\": {\n            \"value\": \"<p class=\\\"compendium-hr\\\">Starting at 2nd level, you can use your action to magically assume the shape of a beast that you have seen before. You can use this feature twice. You regain expended uses when you finish a short or long rest.</p>\"\n        },\n        \"activation\": {\n            \"type\": \"action\",\n            \"cost\": 1\n        },\n        \"target\": {\n            \"type\": \"self\"\n        },\n        \"range\": {\n            \"units\": \"self\"\n        },\n        \"actionType\": \"util\",\n        \"requirements\": \"Druid\"\n    },\n    \"flags\": {\n        \"core\": {\n            \"sourceId\": \"Item.GDRnvEUCgN7N5nkW\"\n        },\n        \"itemacro\": {\n            \"macro\": {\n                \"data\": {\n                    \"_id\": null,\n                    \"name\": \"Wild Shape (Revert)\",\n                    \"type\": \"script\",\n                    \"author\": \"Tyd5yiqWrRZMvG30\",\n                    \"img\": \"icons/svg/dice-target.svg\",\n                    \"scope\": \"global\",\n                    \"command\": \"async function wait(ms) { return new Promise(resolve => { setTimeout(resolve, ms); }); }\\nconst lastArg = args[args.length - 1];\\nlet tactor;\\nif (lastArg.tokenId) tactor = canvas.tokens.get(lastArg.tokenId).actor;\\nelse tactor = game.actors.get(lastArg.actor._id);\\nlet target = canvas.tokens.get(lastArg.tokenId);\\nlet getResources = tactor.data.data.resources.tertiary.value;\\nlet getEffect = tactor.effects.find(i => i.data.label === \\\"Wild Shape\\\");\\nlet effectActor = await game.actors.get(getEffect.data.changes[0].value);\\nlet keys = Object.keys(tactor.data.data.spells);\\nlet updates = keys.reduce((acc, values, i) => {\\n    let primaryLabel = \\\"data.resources.primary.label\\\";\\n    let primaryValue = \\\"data.resources.primary.value\\\";\\n    let primaryMax = \\\"data.resources.primary.max\\\";\\n    let secondaryLabel = \\\"data.resources.secondary.label\\\";\\n    let secondaryValue = \\\"data.resources.secondary.value\\\";\\n    let secondaryMax = \\\"data.resources.secondary.max\\\";\\n    let tertiaryLabel = \\\"data.resources.tertiary.label\\\";\\n    let tertiaryValue = \\\"data.resources.tertiary.value\\\";\\n    let tertiaryMax = \\\"data.resources.tertiary.max\\\";\\n    let spellMin = `data.spells.${values}.value`;\\n    let spellMax = `data.spells.${values}.max`;\\n    tactor.data.data.resources.primary.label != null ? acc[primaryLabel] = tactor.data.data.resources.primary.label : null;\\n    tactor.data.data.resources.primary.label != null ? acc[primaryValue] = tactor.data.data.resources.primary.value : null;\\n    tactor.data.data.resources.primary.label != null ? acc[primaryMax] = tactor.data.data.resources.primary.max : null;\\n    tactor.data.data.resources.secondary.label != null ? acc[secondaryLabel] = tactor.data.data.resources.secondary.label : null;\\n    tactor.data.data.resources.secondary.label != null ? acc[secondaryValue] = tactor.data.data.resources.secondary.value : null;\\n    tactor.data.data.resources.secondary.label != null ? acc[secondaryMax] = tactor.data.data.resources.secondary.max : null;\\n    tactor.data.data.resources.tertiary.label != null ? acc[tertiaryLabel] = tactor.data.data.resources.tertiary.label : null;\\n    tactor.data.data.resources.tertiary.label != null ? acc[tertiaryValue] = tactor.data.data.resources.tertiary.value : null;\\n    tactor.data.data.resources.tertiary.label != null ? acc[tertiaryMax] = tactor.data.data.resources.tertiary.max : null;\\n    acc[spellMin] = Object.values(tactor.data.data.spells)[i].value;\\n    acc[spellMax] = Object.values(tactor.data.data.spells)[i].max;\\n    return acc;\\n}, {});\\nawait effectActor.update(updates);\\nawait wait(500);\\nconst getToken = duplicate(target.data);\\nif ((!(game.modules.get(\\\"jb2a_patreon\\\")?.active) && !(game.modules.get(\\\"sequencer\\\")?.active))){\\n    await tactor.revertOriginalForm();    \\n    await effectActor.revertOriginalForm();        \\n    await MidiQOL.socket().executeAsGM(\\\"removeEffects\\\", { actorUuid: effectActor.uuid, effects: [getEffect.id] });\\n    await canvas.scene.updateEmbeddedDocuments(\\\"Token\\\", [{\\\"_id\\\": getToken._id, \\\"displayBars\\\" : CONST.TOKEN_DISPLAY_MODES.ALWAYS, \\\"mirrorX\\\" : getToken.mirrorX, \\\"mirrorY\\\" : getToken.mirrorY, \\\"rotation\\\" : getToken.rotation, \\\"elevation\\\": getToken.elevation}]);\\n    await game.actors.get(tactor.id).delete();\\n} else {\\n    new Sequence()\\n        .effect()\\n        .atLocation(target)\\n        .file(\\\"jb2a.misty_step.02.green\\\")\\n        .scaleToObject(1.5)\\n        .wait(1000)\\n        .thenDo(async function(){            \\n            await tactor.revertOriginalForm();            \\n            await effectActor.revertOriginalForm();\\n            await MidiQOL.socket().executeAsGM(\\\"removeEffects\\\", { actorUuid: effectActor.uuid, effects: [getEffect.id] });                       \\n            await canvas.scene.updateEmbeddedDocuments(\\\"Token\\\", [{\\\"_id\\\": getToken._id, \\\"displayBars\\\" : CONST.TOKEN_DISPLAY_MODES.ALWAYS, \\\"mirrorX\\\" : getToken.mirrorX, \\\"mirrorY\\\" : getToken.mirrorY, \\\"rotation\\\" : getToken.rotation, \\\"elevation\\\": getToken.elevation}]);\\n            await game.actors.get(tactor.id).delete();\\n        })\\n    .play()\\n}\",\n                    \"folder\": null,\n                    \"sort\": 0,\n                    \"permission\": {\n                        \"default\": 0\n                    },\n                    \"flags\": {}\n                }\n            }\n        },\n        \"favtab\": {\n            \"isFavorite\": true\n        },\n        \"midi-qol\": {\n            \"onUseMacroName\": \"[postActiveEffects]ItemMacro\",\n            \"effectActivation\": false\n        }\n    }\n}];\n\nif ((args[0] === \"on\") && (!tactor.isPolymorphed)) {\n    new Dialog({\n        title: itemD.name,\n        content: the_content,\n        buttons: {\n            change: {\n                label: \"Change\", callback: async (html) => {\n                    let polyId = html.find('#beast')[0].value;\n                    let findToken = getFolder.find(i => i.id === polyId);\n                    const getToken = duplicate(target.data);\n                    if ((!(game.modules.get(\"jb2a_patreon\")?.active) && !(game.modules.get(\"sequencer\")?.active))) {\n                        await tactor.transformInto(findToken, { keepBio: true, keepClass: true, keepMental: true, mergeSaves: true, mergeSkills: true, transformTokens: true });\n                    } else {\n                        new Sequence()\n                            .effect()\n                            .atLocation(target)\n                            .file(\"jb2a.misty_step.01.green\")\n                            .scaleToObject(1.5)\n                            .thenDo(async function () {\n                                await tactor.transformInto(findToken, { keepBio: true, keepClass: true, keepMental: true, mergeSaves: true, mergeSkills: true, transformTokens: true });\n                            })\n                            .play()\n                    }\n                    await wait(1000);\n                    let combatWildShape = tactor.items.find(i => i.name === \"Combat Wild Shape\");\n                    let findPoly = await game.actors.find(i => i.name === `${tactor.name} (${findToken.name})`);\n                    await canvas.scene.updateEmbeddedDocuments(\"Token\", [{ \"_id\": getToken._id, \"displayBars\": CONST.TOKEN_DISPLAY_MODES.ALWAYS, \"mirrorX\": getToken.mirrorX, \"mirrorY\": getToken.mirrorY, \"rotation\": getToken.rotation, \"elevation\": getToken.elevation }]);\n                    let wsRevert = findPoly.items.find(i => i.name === \"Wild Shape (Revert)\");\n                    let wsHealing = findPoly.items.find(i => i.name === \"Wild Shape Healing\");\n                    let keys = Object.keys(tactor.data.data.spells);\n                    let updates = keys.reduce((acc, values, i) => {\n                        let primaryLabel = \"data.resources.primary.label\";\n                        let primaryValue = \"data.resources.primary.value\";\n                        let primaryMax = \"data.resources.primary.max\";\n                        let secondaryLabel = \"data.resources.secondary.label\";\n                        let secondaryValue = \"data.resources.secondary.value\";\n                        let secondaryMax = \"data.resources.secondary.max\";\n                        let tertiaryLabel = \"data.resources.tertiary.label\";\n                        let tertiaryValue = \"data.resources.tertiary.value\";\n                        let tertiaryMax = \"data.resources.tertiary.max\";\n                        let spellMin = `data.spells.${values}.value`;\n                        let spellMax = `data.spells.${values}.max`;\n                        if (combatWildShape) {\n                            acc[spellMin] = Object.values(tactor.data.data.spells)[i].value;\n                            acc[spellMax] = Object.values(tactor.data.data.spells)[i].max;\n                        }\n                        if (tactor.data.data.resources.primary.label != null) {\n                            acc[primaryLabel] = tactor.data.data.resources.primary.label;\n                            acc[primaryValue] = tactor.data.data.resources.primary.value;\n                            acc[primaryMax] = tactor.data.data.resources.primary.max;\n                        }\n                        if (tactor.data.data.resources.secondary.label != null) {\n                            acc[secondaryLabel] = tactor.data.data.resources.secondary.label;\n                            acc[secondaryValue] = tactor.data.data.resources.secondary.value;\n                            acc[secondaryMax] = tactor.data.data.resources.secondary.max;\n                        }\n                        if (tactor.data.data.resources.tertiary.label != null) {\n                            acc[tertiaryLabel] = tactor.data.data.resources.tertiary.label;\n                            acc[tertiaryValue] = tactor.data.data.resources.tertiary.value;\n                            acc[tertiaryMax] = tactor.data.data.resources.tertiary.max;\n                        }\n                        return acc;\n                    }, {});\n                    await findPoly.update(updates);\n                    await findPoly.createEmbeddedDocuments(\"Item\", druidItems);\n                    if (!wsRevert) await findPoly.createEmbeddedDocuments(\"Item\", wildshapeRevert);\n                    if ((combatWildShape) && (!wsHealing)) await findPoly.createEmbeddedDocuments(\"Item\", wildshapeHealing);\n                }\n            }\n        },\n        default: \"change\"\n    }).render(true);\n}\nif ((args[0] === \"on\") && (tactor.isPolymorphed)) {\n    let effect = tactor.effects.find(i => i.data.label === itemD.name);\n    if (effect) await MidiQOL.socket().executeAsGM(\"removeEffects\", { actorUuid: tactor.uuid, effects: [effect.id] });\n}\nif (args[0] === \"off\") {\n    await tactor.revertOriginalForm();\n}","folder":null,"sort":0,"permission":{"default":0},"flags":{}}}},"favtab":{"isFavorite":true},"midi-qol":{"onUseMacroName":"","forceCEOn":false,"effectActivation":false},"exportSource":{"world":"darklands","system":"dnd5e","coreVersion":"9.254","systemVersion":"1.5.7"}},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":1669440918468,"modifiedTime":1669440918468,"lastModifiedBy":"T4cu5jv0VXcrhb1w"},"_id":"ocdkLJeCWz3FP07k","folder":null,"sort":0,"ownership":{"default":0,"T4cu5jv0VXcrhb1w":3}}
{"name":"Sharpshooter","type":"feat","img":"icons/skills/ranged/target-bullseye-arrow-glowing.webp","system":{"description":{"value":"<p>You have mastered ranged weapons and can make shots that others find impossible. You gain the following benefits:</p>\n<ul>\n<li>Attacking at long range doesn't impose disadvantage on your ranged weapon attack rolls.</li>\n<li>Your ranged weapon attacks ignore half cover and three-quarters cover.</li>\n<li>Before you make an attack with a ranged weapon that you are proficient with, you can choose to take a -5 penalty to the attack roll. If the attack hits, you add +10 to the attack's damage.</li>\n</ul>","chat":"","unidentified":""},"source":"","activation":{"type":"special","cost":null,"condition":""},"duration":{"value":null,"units":""},"target":{"value":null,"width":null,"units":"","type":"self"},"range":{"value":null,"long":null,"units":"self"},"uses":{"value":null,"max":"","per":null,"recovery":""},"consume":{"type":"","target":null,"amount":null},"ability":null,"actionType":"util","attackBonus":0,"chatFlavor":"","critical":{"threshold":null,"damage":""},"damage":{"parts":[],"versatile":""},"formula":"","save":{"ability":"","dc":null,"scaling":"spell"},"requirements":"","recharge":{"value":null,"charged":false}},"effects":[],"flags":{"midi-qol":{"onUseMacroName":"[postActiveEffects]ItemMacro","effectActivation":false,"forceCEOff":true,"forceCEOn":false},"itemacro":{"macro":{"data":{"_id":null,"name":"Sharpshooter","type":"script","author":"Tyd5yiqWrRZMvG30","img":"icons/svg/dice-target.svg","scope":"global","command":"//#####################################\n// READ THIS\n// Requires Midi-QoL on use\n//####################################\nconst lastArg = args[args.length - 1];\nlet tactor;\nif (lastArg.tokenId) tactor = canvas.tokens.get(lastArg.tokenId).actor;\nelse tactor = game.actors.get(lastArg.actorId);\nlet itemD = lastArg.item;\nlet gameRound = game.combat ? game.combat.round : 0;\nlet the_message = \"\";\nlet effect = await tactor.effects.find(i => i.data.label === itemD.name);\nif (effect) {\n    await MidiQOL.socket().executeAsGM(\"removeEffects\", { actorUuid: tactor.uuid, effects: [effect.id] });\n    the_message = `<em>${tactor.name} is aiming <strong>Normally</strong> now.</em>`;\n} else {\n    let effectData = [{\n        label: itemD.name,\n        icon: itemD.img,\n        duration: { rounds: 1, startRound: gameRound, startTime: game.time.worldTime },\n        origin: lastArg.uuid,\n        changes: [{\n            \"key\": \"data.bonuses.rwak.damage\",\n            \"mode\": CONST.ACTIVE_EFFECT_MODES.CUSTOM,\n            \"value\": 10,\n            \"priority\": 20\n        }, {\n            \"key\": \"data.bonuses.rwak.attack\",\n            \"mode\": CONST.ACTIVE_EFFECT_MODES.CUSTOM,\n            \"value\": \"-5\",\n            \"priority\": 20\n        }]\n    }];\n    await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: tactor.uuid, effects: effectData });\n    the_message = `<em>${tactor.name} is aiming <strong>Carefully</strong> now!</em>`;\n}\nlet chatMessage = game.messages.get(lastArg.itemCardId);\nlet content = await duplicate(chatMessage.data.content);\nlet searchString = /<div class=\"midi-qol-saves-display\">[\\s\\S]*<div class=\"end-midi-qol-saves-display\">/g;\nlet replaceString = `<div class=\"midi-qol-saves-display\"><div class=\"end-midi-qol-saves-display\">${the_message}`;\ncontent = content.replace(searchString, replaceString);\nawait chatMessage.update({ content: content });\nawait ui.chat.scrollBottom();","folder":null,"sort":0,"permission":{"default":0},"flags":{}}}},"favtab":{"isFavorite":true}},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":1669440918463,"modifiedTime":1669440918463,"lastModifiedBy":"T4cu5jv0VXcrhb1w"},"_id":"ou58PxwJHvFXoIjQ","folder":null,"sort":0,"ownership":{"default":0,"T4cu5jv0VXcrhb1w":3}}
{"name":"Nemico prescelto - Diventa il nemico-","type":"feat","img":"icons/skills/targeting/crosshair-mark-rough-pink.webp","system":{"description":{"value":"<p><em>Privilegio del Ranger di 6° livello, che rimpiazza il Privilegio <strong>Nemico Prescelto Migliorato</strong></em></p><p></p><p>Il ranger ha appreso le abilità e le doti dei propri nemici prescelti e grazie alla magia è riuscito non solo a riprodurli ma anche a perfezionarle in modo da danneggiare i suoi avversari. Quando il ranger danneggia un suo nemico prescelto aggiunge un dado dell'arma che sta utilizzando ai danni totali; Se il nemico prescelto ha una resistenza a quel danno, il ranger la supera. Al livello 14 il ranger aggiunge due dadi in più invece di uno ai danni; e se quel nemico è immune può decidere di ignorarlo per 1 minuto come parte del primo attacco che esegue a riposo lungo.</p><ul><li>Aberrazioni (psichico)</li><li>Bestie (Perforanti)</li><li>Celestiali (Radianti)</li><li>Costrutti(Contundenti)</li><li>Draghi (Scegli un elemento)</li><li>Elementali (Forza)</li><li>Folletti (Tuono o fulmine)</li><li>Giganti (Scegli un elemento)</li><li>Immondi (Fuoco o Freddo)</li><li>Melme (Acido)</li><li>Mostruosità (Taglienti)</li><li>Non Morti (Necrotici)</li><li>Vegetali (Veleno)</li><li>Umanoide (Scegli un elemento)</li></ul>","chat":"","unidentified":""},"source":"Archer","activation":{"type":"","cost":0,"condition":""},"duration":{"value":null,"units":""},"target":{"value":null,"width":null,"units":"","type":""},"range":{"value":null,"long":null,"units":""},"uses":{"value":null,"max":"","per":null,"recovery":""},"consume":{"type":"","target":null,"amount":null},"ability":null,"actionType":"","attackBonus":0,"chatFlavor":"","critical":{"threshold":null,"damage":""},"damage":{"parts":[],"versatile":""},"formula":"","save":{"ability":"","dc":null,"scaling":"spell"},"requirements":"","recharge":{"value":null,"charged":false}},"effects":[],"ownership":{"default":0,"T4cu5jv0VXcrhb1w":3},"flags":{"core":{"sourceId":"Item.bniLDuM3s6Oamuos"}},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":1666632256733,"modifiedTime":1669438474262,"lastModifiedBy":"T4cu5jv0VXcrhb1w"},"folder":null,"sort":0,"_id":"qxo2jHzceo1eXcQ4"}
{"name":"Channel Divinity: Guided Strike","type":"feat","img":"icons/skills/melee/strike-weapons-orange.webp","system":{"description":{"value":"<p>You can use your Channel Divinity to strike with supernatural accuracy. When you make an attack roll, you can use your Channel Divinity to gain a +10 bonus to the roll. You make this choice after you see the roll, but before the DM says whether the attack hits or misses.</p>","chat":"","unidentified":""},"source":"","activation":{"type":"","cost":null,"condition":""},"duration":{"value":null,"units":""},"target":{"value":null,"width":null,"units":"","type":""},"range":{"value":null,"long":null,"units":""},"uses":{"value":null,"max":"","per":"","recovery":""},"consume":{"type":"","target":"","amount":null},"ability":"","actionType":"","attackBonus":"0","chatFlavor":"","critical":{"threshold":null,"damage":""},"damage":{"parts":[],"versatile":""},"formula":"","save":{"ability":"","dc":null,"scaling":"spell"},"requirements":"","recharge":{"value":null,"charged":false}},"effects":[{"_id":"ei0fqrpg557juauo","changes":[{"key":"flags.midi-qol.onUseMacroName","mode":0,"value":"ItemMacro.Channel Divinity: Guided Strike,preCheckHits","priority":20}],"disabled":false,"duration":{"startTime":null,"seconds":null,"combat":null,"rounds":null,"turns":null,"startRound":null,"startTurn":null},"icon":"icons/skills/melee/strike-weapons-orange.webp","label":"Channel Divinity: Guided Strike","transfer":true,"flags":{"dae":{"selfTarget":false,"stackable":"none","durationExpression":"","macroRepeat":"none","specialDuration":[],"transfer":true},"core":{"statusId":""},"dnd5e-helpers":{"rest-effect":"Ignore"},"ActiveAuras":{"isAura":false,"aura":"None","radius":null,"alignment":"","type":"","ignoreSelf":false,"height":false,"hidden":false,"displayTemp":false,"hostile":false,"onlyOnce":false}},"tint":null,"origin":null}],"flags":{"magicitems":{"enabled":false,"equipped":false,"attuned":false,"charges":"0","chargeType":"c1","destroy":false,"destroyFlavorText":"reaches 0 charges: it crumbles into ashes and is destroyed.","rechargeable":false,"recharge":"0","rechargeType":"t1","rechargeUnit":"r1","sorting":"l"},"midi-qol":{"fumbleThreshold":null,"effectActivation":false,"onUseMacroName":""},"midiProperties":{"nodam":false,"fulldam":false,"halfdam":false,"rollOther":false,"critOther":false,"magicdam":false,"magiceffect":false,"concentration":false,"toggleEffect":false},"itemacro":{"macro":{"_id":null,"name":"Channel Divinity: Guided Strike","type":"script","author":"Tyd5yiqWrRZMvG30","img":"icons/svg/dice-target.svg","scope":"global","command":"async function wait(ms) { return new Promise(resolve => { setTimeout(resolve, ms); }); }\nconst lastArg = args[args.length - 1];\nconst tokenD = canvas.tokens.get(lastArg.tokenId);\nconst actorD = tokenD.actor;\nconst actorData = actorD.getRollData();\nconst firstTotal = duplicate(lastArg.attackTotal);\nlet itemName = \"Channel Divinity: Guided Strike\";\nlet guided = actorD.items.find(i=> i.name === itemName);\nconst itemD = lastArg.item;\nif(!guided) return ui.notifications.error(`Looking for an item named ${itemName}, cannot find it.`);\nconst target = canvas.tokens.get(lastArg.targets[0].id);\nif (![\"ak\"].some(i => (itemD.data.actionType).toLowerCase().includes(i))) return {};\nlet resourceName = \"Channel Divinity\";\nlet resourceList = [{ name: \"primary\" }, { name: \"secondary\" }, { name: \"tertiary\" }];\nlet resourceValues = Object.values(actorData.resources);\nlet resourceTable = mergeObject(resourceList, resourceValues);\nlet findResourceSlot = resourceTable.find(i => i.label.toLowerCase() === resourceName.toLowerCase());\nif (!findResourceSlot) return ui.notifications.error(`${resourceName} Resources is missing on ${tokenD.name}, Add it.`);\nlet resourceSlot = findResourceSlot.name;\nlet curtRes = actorData.resources[resourceSlot].value;\nlet curtMax = actorData.resources[resourceSlot].value;\nif (curtRes < 1) return console.warn(guided.name, curtRes,`out of resources`);\nif (lastArg.macroPass === \"preCheckHits\") {\n    if (lastArg.attackTotal >= target.actor.getRollData().attributes.ac.value) return console.warn(guided.name, lastArg.attackTotal, \"attack hit, no need\");\n    if ((lastArg.attackTotal + 10) < target.actor.getRollData().attributes.ac.value) return console.warn(guided.name, lastArg.attackTotal, \"attack too low\");\n    let workflow = await MidiQOL.Workflow.getWorkflow(lastArg.uuid);\n    let guidingStrike = await new Promise((resolve) => {\n        let the_content = `You missed your target with an <b>${lastArg.attackTotal}</b>. Channel Divinity [${curtRes}/${curtMax}]`;\n        new Dialog({\n            title: guided.name,\n            content: the_content,\n            buttons: {\n                use: {\n                    label: `Use`, icon: `<img src=\"${guided.data.img}\" width=\"30px\" height=\"30px\">`, callback: async () => resolve(true)\n                },\n                skip: {\n                    label: \"Skip\", callback: () => resolve(false)\n                }\n            },\n            default: \"Skip\"\n        }).render(true);\n    });    \n    if (!guidingStrike) return {};\n    workflow.attackD20 = lastArg.attackD20 + 10;\n    workflow.diceRoll = lastArg.diceRoll + 10;\n    let newAttackRoll = await new Roll(`${lastArg.attackTotal} + 10`).evaluate({ async: true });\n    workflow.attackRoll = newAttackRoll;\n    workflow.attackTotal = newAttackRoll.total;\n    switch (MidiQOL.configSettings().rollAlternate) {\n        case \"formula\":\n        case \"formulaadv\": workflow.attackRollHTML = await newAttackRoll.render({ template: \"modules/midi-qol/templates/rollAlternate.html\" }); break;\n        case \"adv\":\n        case \"off\":\n        default: workflow.attackRollHTML = await newAttackRoll.render(); // \"off\"\n    }\n    let updates = {};\n    let resources = `data.resources.${resourceSlot}.value`;\n    updates[resources] = curtRes - 1;\n    await actorD.update(updates);\n    await wait(300);\n    let the_message = `<em>${guided.name}.<br>${tokenD.name} strikes with supernatural accuracy!</em>`;\n    let chatMessage = game.messages.get(lastArg.itemCardId);\n    let content = await duplicate(chatMessage.data.content);\n    let searchString = /<div class=\"midi-qol-saves-display\">[\\s\\S]*<div class=\"end-midi-qol-saves-display\">/g;\n    let replaceString = `<div class=\"midi-qol-saves-display\"><div class=\"end-midi-qol-saves-display\"><hr>${the_message}`;\n    content = content.replace(searchString, replaceString);\n    await chatMessage.update({ content: content });\n    await ui.chat.scrollBottom();\n}","folder":null,"sort":0,"permission":{"default":0},"flags":{}}},"core":{"sourceId":"Item.R8CF2siOwGCMf5bd"},"exportSource":{"world":"darklands","system":"dnd5e","coreVersion":"9.280","systemVersion":"1.6.3"}},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":1669440918453,"modifiedTime":1669440918453,"lastModifiedBy":"T4cu5jv0VXcrhb1w"},"_id":"secuglhJ6nl5QjDz","folder":null,"sort":0,"ownership":{"default":0,"T4cu5jv0VXcrhb1w":3}}
{"name":"Tentacle of the Deeps","type":"feat","img":"icons/commodities/biological/tentacle-pink.webp","system":{"description":{"value":"<p><em>1st-level Fathomless feature</em></p>\n<p>You can magically summon a spectral tentacle that strikes at your foes. As a bonus action, you create a 10-foot-long tentacle at a point you can see within 60 feet of you. The tentacle lasts for 1 minute or until you use this feature to create another tentacle.</p>\n<p>When you create the tentacle, you can make a melee spell attack against one creature within 10 feet of it. On a hit, the target takes 1d8 cold damage, and its speed is reduced by 10 feet until the start of your next turn. When you reach 10th level in this class, the damage increases to 2d8.</p>\n<p>As a bonus action on your turn, you can move the tentacle up to 30 feet and repeat the attack. You can summon the tentacle a number of times equal to your proficiency bonus, and you regain all expended uses when you finish a long rest.</p>\n<h3>Summary</h3>\n<p>As a bonus action, you create a 10-foot-long tentacle at a point you can see within 60 ft. of you. The tentacle lasts for 1 minute or until you use this feature to create another tentacle. When you create the tentacle, you can make a melee spell attack against one creature within 10 ft. of it.</p>","chat":"As a bonus action, you create a 10-foot-long tentacle at a point you can see within 60 ft. of you. The tentacle lasts for 1 minute or until you use this feature to create another tentacle.\nWhen you create the tentacle, you can make a melee spell attack against one creature within 10 ft. of it.","unidentified":""},"source":"","activation":{"type":"bonus","cost":1,"condition":""},"duration":{"value":1,"units":"minute"},"target":{"value":null,"width":null,"units":"","type":"self"},"range":{"value":null,"long":null,"units":"self"},"uses":{"value":2,"max":"3","per":"lr","recovery":""},"consume":{"type":"attribute","target":"","amount":null},"ability":"","actionType":"other","attackBonus":0,"chatFlavor":"","critical":{"threshold":null,"damage":null},"damage":{"parts":[],"versatile":""},"formula":"","save":{"ability":"","dc":null,"scaling":"spell"},"requirements":"","recharge":{"value":null,"charged":false}},"effects":[{"_id":"1QO8ZR6szXvVBg91","changes":[{"key":"macro.itemMacro","mode":0,"value":"@classes.warlock.levels @attributes.spellcasting","priority":20}],"disabled":false,"duration":{"startTime":null,"seconds":null,"combat":null,"rounds":null,"turns":null,"startRound":null,"startTurn":null},"icon":"icons/commodities/biological/tentacle-purple-white.webp","label":"Tentacle of the Deeps","transfer":false,"flags":{"dae":{"stackable":"none","macroRepeat":"none","specialDuration":[],"transfer":false,"durationExpression":"","selfTarget":false},"ActiveAuras":{"isAura":false,"radius":null,"aura":"None","alignment":"","type":"","ignoreSelf":false,"height":false,"hidden":false,"hostile":false,"onlyOnce":false,"displayTemp":false},"core":{"statusId":""},"dnd5e-helpers":{"rest-effect":"Ignore"}},"tint":null,"origin":null}],"flags":{"ddbimporter":{"id":"2397931","entityTypeId":"222216831","componentId":2986291,"componentTypeId":12168134,"dndbeyond":{"levelScale":{"id":383418,"level":1,"description":"1d8 cold damage","dice":{"diceCount":1,"diceValue":8,"diceMultiplier":null,"fixedValue":null,"diceString":"1d8"},"fixedValue":null},"levelScales":[{"id":383418,"level":1,"description":"1d8 cold damage","dice":{"diceCount":1,"diceValue":8,"diceMultiplier":null,"fixedValue":null,"diceString":"1d8"},"fixedValue":null},{"id":383419,"level":10,"description":"2d8 cold damage","dice":{"diceCount":2,"diceValue":8,"diceMultiplier":null,"fixedValue":null,"diceString":"2d8"},"fixedValue":null}],"limitedUse":[{"level":null,"uses":1},{"level":null,"uses":1},{"level":null,"uses":1}]}},"betterRolls5e":{"quickCharges":{"value":{"use":true,"resource":true},"altValue":{"use":true,"resource":true}}},"favtab":{"isFavorite":true},"midi-qol":{"onUseMacroName":"","forceCEOn":false,"effectActivation":false},"magicitems":{"enabled":false,"equipped":false,"attuned":false,"charges":"0","chargeType":"c1","destroy":false,"destroyFlavorText":"reaches 0 charges: it crumbles into ashes and is destroyed.","rechargeable":false,"recharge":"0","rechargeType":"t1","rechargeUnit":"r1","sorting":"l"},"core":{"sourceId":"Item.lVdDJk2OHbpIwOLZ"},"itemacro":{"macro":{"data":{"_id":null,"name":"Tentacle of the Deep","type":"script","author":"Tyd5yiqWrRZMvG30","img":"icons/svg/dice-target.svg","scope":"global","command":"//DAE Item Macro Execute, value = @item.level.id\n// Set spell to self cast, no damage/attack roll\nasync function wait(ms) { return new Promise(resolve => { setTimeout(resolve, ms); }); }\nconst lastArg = args[args.length - 1];\nlet tactor;\nif (lastArg.tokenId) tactor = canvas.tokens.get(lastArg.tokenId).actor;\nelse tactor = game.actors.get(lastArg.actorId);\nconst tokenD = canvas.tokens.get(lastArg.tokenId);\nconst actorData = tactor.getRollData();\nconst casterLevel = Number(args[1]);\nconst damageDice = Math.floor(casterLevel/10) + 1;\nconst castingStat = args[2];\nconst castingItem = lastArg.efData.flags.dae.itemData;\nconst summonTarget = castingItem.name;\nconst damageType = \"cold\";\n\nlet findActor = game.actors.find(i => i.name === summonTarget);\nlet warpgateCheck = ((game.modules.get(\"warpgate\")) && (game.modules.get(\"warpgate\")?.active)) ? true : false;\nlet sequencerCheck = ((game.modules.get(\"sequencer\")) && (game.modules.get(\"sequencer\")?.active)) ? true : false;\nlet jb2aCheck = ((game.modules.get(\"JB2A_DnD5e\")) && (game.modules.get(\"JB2A_DnD5e\")?.active)) || ((game.modules.get(\"jb2a_patreon\")) && (game.modules.get(\"jb2a_patreon\")?.active)) ? true : false;\n\nif (!findActor || !warpgateCheck || !sequencerCheck || !jb2aCheck) {\n    let effect = tokenD.actor.effects.find(i => i.data.label === summonTarget);\n    await MidiQOL.socket().executeAsGM(\"removeEffects\", { actorUuid: tokenD.actor.uuid, effects: [effect.id] });\n    if (!findActor) return ui.notifications.error(`${summonTarget} actor is missing, create an actor named '${summonTarget}'`);\n    if (!warpgateCheck) return ui.notifications.error(\"Warpgate Module is missing, Install it.\");\n    if (!sequencerCheck) return ui.notifications.error(\"Sequencer Module is missing, Install it.\");\n    if (!jb2aCheck) return ui.notifications.error(\"JB2A is required [free or paid version], install one of them\");\n}\n/**\n * Create weapon item in inventory\n */\nif (args[0] === \"on\") {\n    let maxGrid = canvas.grid.size >= 84 ? 84 : (canvas.grid.size - 3);\n    let range = await canvas.scene.createEmbeddedDocuments(\"MeasuredTemplate\", [{\n        t: \"circle\",\n        user: game.user.id,\n        x: tokenD.x + canvas.grid.size / 2,\n        y: tokenD.y + canvas.grid.size / 2,\n        direction: 0,\n        distance: maxGrid,\n        borderColor: \"#FF0000\"\n    }]);\n\n    let updates = {\n        token: {\n            \"name\": `${summonTarget} ${tactor.name}`,\n            \"displayName\": CONST.TOKEN_DISPLAY_MODES.HOVER,\n            \"disposition\": CONST.TOKEN_DISPOSITIONS.NEUTRAL,\n            \"alpha\": 0\n        },\n        actor: {\n            \"name\": `${summonTarget} ${tactor.name}`,\n            \"data.details.type\": { value: \"custom\", custom: \"NoTarget\" },\n            \"data.attributes.hp\": { value: 999, max: 999 },\n            \"data.details.cr\": actorData.classes.warlock.levels ?? actorData.details.cr,\n            \"data.abilities.cha.value\": actorData.abilities.cha.value,\n            \"data.attributes.movement\": { walk: 30, fly: 30, hover: true },\n            \"flags.summons.actorId\": tactor.id            \n        },\n        embedded: {\n            Item: {\n                \"Tentacle\": {\n                    \"data.ability\": castingStat,\n                    \"data.damage.parts\": [[`${damageDice}d8[${damageType}]`, damageType]]\n                }\n            }\n        }\n    }\n\n    async function myEffectFunction(template, update) {\n        new Sequence()\n            .effect()\n            .file(\"jb2a.impact_themed.ice_shard.blue\")\n            .atLocation(template)\n            .fadeIn(400, { ease: \"easeOutCirc\", delay: 100 })\n            .fadeOut(400, { ease: \"easeOutCirc\", delay: -100 })\n            .center()\n            .scale(1.5)\n            .belowTokens()\n            .play()\n    }\n\n    async function postEffects(template, token) {\n        //bring in our minion\n        new Sequence()\n            .animation()\n            .on(token)\n            .fadeIn(500)\n            .play()\n    }\n\n    const callbacks = {\n        pre: async (template, update) => {\n            await range[0].delete();\n            myEffectFunction(template, update);\n            await warpgate.wait(1750);\n        },\n        post: async (template, token) => {\n            postEffects(template, token);\n            await warpgate.wait(500);\n        }\n    };\n\n    let options = { controllingActor: tactor };\n\n    await warpgate.spawn(summonTarget, updates, callbacks, options);\n\n    let itemData = [{\n        \"name\": `${summonTarget}: Attack`,\n        \"type\": \"feat\",\n        \"img\": \"icons/commodities/biological/tentacle-purple-white.webp\",\n        \"data\": {\n            \"description\": {\n                \"value\": `<p>You can make a melee spell attack against one creature within 10 feet of it. On a hit, the target takes ${damageDice}d8 cold damage, and its speed is reduced by 10 feet until the start of your next turn.</p>`\n            },\n            \"activation\": {\n                \"type\": \"bonus\",\n                \"cost\": 1\n            },\n            \"actionType\": \"util\"\n        },\n        \"flags\": {\n            \"summons\": {\n                \"actorId\": tactor.id\n            },\n            \"itemacro\": {\n                \"macro\": {\n                    \"data\": {\n                        \"_id\": null,\n                        \"name\": `${summonTarget}: Attack`,\n                        \"type\": \"script\",\n                        \"author\": \"Tyd5yiqWrRZMvG30\",\n                        \"img\": \"icons/svg/dice-target.svg\",\n                        \"scope\": \"global\",\n                        \"command\": \"const lastArg = args[args.length - 1];\\nlet summonName = [\\\"tentacle of the deep\\\"];\\nlet target = canvas.tokens.placeables.find(i => summonName.some(x=> (i.name).toLowerCase().includes(x)));\\nlet getItem = target.actor.items.getName(\\\"Tentacle\\\");\\nawait getItem.roll();\",\n                        \"folder\": null,\n                        \"sort\": 0,\n                        \"permission\": {\n                            \"default\": 0\n                        },\n                        \"flags\": {}\n                    }\n                }\n            },\n            \"favtab\": {\n                \"isFavorite\": true\n            },\n            \"midi-qol\": {\n                \"effectActivation\": false,\n                \"onUseMacroName\": \"[postActiveEffects]ItemMacro\"\n            }\n        }\n    }];\n    if(casterLevel >= 6) itemData.push({\n        \"name\": \"Guardian Coil\",\n        \"type\": \"feat\",\n        \"img\": \"icons/commodities/biological/tentacle-yellow.webp\",\n        \"data\": {\n            \"description\": {\n                \"value\": \"<p><em>6th-level Fathomless feature </em></p>\\n<p>Your Tentacle of the Deeps can defend you and others, interposing itself between them and harm. When you or a creature you can see takes damage while within 10 feet of the tentacle, you can use your reaction to choose one of those creatures and reduce the damage to that creature by 1d8. When you reach 10th level in this class, the damage reduced by the tentacle increases to 2d8.</p>\\n\\n\"\n            },\n            \"activation\": {\n                \"type\": \"reactionmanual\",\n                \"cost\": 1,\n                \"condition\": \"\"\n            },\n            \"duration\": {\n                \"value\": 1,\n                \"units\": \"minute\"\n            },\n            \"target\": {\n                \"value\": 1,\n                \"width\": null,\n                \"units\": \"\",\n                \"type\": \"creature\"\n            },\n            \"save\": {\n                \"ability\": \"\",\n                \"dc\": null,\n                \"scaling\": \"spell\"\n            },\n            \"requirements\": \"The Fathomless\",\n            \"attunement\": 0\n        },\n        \"effects\": [\n            {\n                \"_id\": \"nVnLGnmr9FCbWgZc\",\n                \"changes\": [\n                    {\n                        \"key\": \"flags.midi-qol.DR.all\",\n                        \"mode\": 5,\n                        \"value\": \"1d8\",\n                        \"priority\": \"20\"\n                    },\n                    {\n                        \"key\": \"macro.itemMacro\",\n                        \"mode\": 0,\n                        \"value\": \"\",\n                        \"priority\": \"20\"\n                    }\n                ],\n                \"disabled\": false,\n                \"icon\": \"icons/commodities/biological/tentacle-yellow.webp\",\n                \"label\": \"Guardian Coil\",\n                \"transfer\": false,\n                \"flags\": {\n                    \"dae\": {\n                        \"stackable\": \"none\",\n                        \"macroRepeat\": \"none\",\n                        \"specialDuration\": [\n                            \"isDamaged\"\n                        ],\n                        \"transfer\": false,\n                        \"durationExpression\": \"\"\n                    }\n                },\n                \"tint\": \"\",\n                \"selectedKey\": [\n                    \"flags.midi-qol.DR.all\",\n                    \"macro.itemMacro\"\n                ]\n            }\n        ],\n        \"flags\": {\n            \"summons\": {\n                \"actorId\": tactor.id\n            },\n            \"itemacro\": {\n                \"macro\": {\n                    \"data\": {\n                        \"_id\": null,\n                        \"name\": \"Guardian Coil\",\n                        \"type\": \"script\",\n                        \"author\": \"Tyd5yiqWrRZMvG30\",\n                        \"img\": \"icons/svg/dice-target.svg\",\n                        \"scope\": \"global\",\n                        \"command\": \"async function wait(ms) { return new Promise(resolve => { setTimeout(resolve, ms); }); }\\nconst lastArg = args[args.length - 1];\\nlet tactor;\\nif (lastArg.tokenId) tactor = canvas.tokens.get(lastArg.tokenId).actor;\\nelse tactor = game.actors.get(lastArg.actorId);\\nconst tokenD = canvas.tokens.get(lastArg.tokenId);\\nif (args[0] === \\\"on\\\") {\\n    new Sequence()\\n        .effect()\\n        .file(\\\"jb2a.markers.bubble.intro.rainbow\\\")\\n        .attachTo(tokenD)\\n        .scale(0.5)\\n        .waitUntilFinished(-500)\\n    .effect()\\n        .file(\\\"jb2a.markers.bubble.loop.rainbow\\\")\\n        .attachTo(tokenD)\\n        .scale(0.5)\\n        .persist()\\n        .name(`Shield-${tokenD.id}`)\\n        .fadeIn(300)\\n        .fadeOut(300)\\n        .extraEndDuration(800)\\n    .play()\\n}\\nif (args[0] === \\\"off\\\") {\\n    Sequencer.EffectManager.endEffects({ name: `Shield-${tokenD.id}`, object: tokenD });\\n    new Sequence()\\n        .effect()\\n            .file(\\\"jb2a.markers.bubble.outro.rainbow\\\")\\n            .scale(0.5)\\n            .attachTo(tokenD)\\n    .play()\\n}\",\n                        \"folder\": null,\n                        \"sort\": 0,\n                        \"permission\": {\n                            \"default\": 0\n                        }\n                    }\n                }\n            },\n            \"favtab\": {\n                \"isFavorite\": true\n            }\n        }\n    });\n    await tactor.createEmbeddedDocuments(\"Item\", itemData);\n    ui.notifications.warn(`${summonTarget}: Attack feature has been added, use that to attack with ${summonTarget}.`);\n}\n// Delete Spitirual Weapon and template\nif (args[0] === \"off\") {\n    let findItems = tactor.items.filter(i => i.data.flags?.summons?.actorId === tactor.id)?.map(i => i.id);\n    if (findItems) await tactor.deleteEmbeddedDocuments(\"Item\", findItems);\n    let findToken = canvas.tokens.placeables.find(i => i.actor.data.flags?.summons?.actorId === tactor.id);\n    if (!findToken) return {};\n    new Sequence()\n        .effect()\n        .file(\"jb2a.impact_themed.ice_shard.blue\")\n        .center()\n        .atLocation(findToken)\n        .scale(findToken.data.width/2)               \n        .animation()\n        .on(findToken)\n        .fadeOut(1000)\n        .thenDo(async function () {\n            await wait(1500);\n            await findToken.document.delete();\n        })\n        .play();\n}","folder":null,"sort":0,"permission":{"default":0},"flags":{}}}},"midiProperties":{"nodam":false,"fulldam":false,"halfdam":false,"rollOther":false,"critOther":false,"magicdam":false,"magiceffect":false,"concentration":false,"toggleEffect":false},"exportSource":{"world":"darklands","system":"dnd5e","coreVersion":"9.269","systemVersion":"1.6.3"}},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":1669440918465,"modifiedTime":1669440918465,"lastModifiedBy":"T4cu5jv0VXcrhb1w"},"_id":"trfsJuTVgC7iq819","folder":null,"sort":0,"ownership":{"default":0,"T4cu5jv0VXcrhb1w":3}}
{"name":"Channel Divinity: Turn the Unholy","type":"feat","img":"icons/magic/unholy/barrier-fire-pink.webp","system":{"description":{"value":"<p>As an action, you present your holy symbol and speak a prayer censuring fiends and undead, using your Channel Divinity. Each fiend or undead that can see or hear you within 30 feet of you must make a Wisdom saving throw. If the creature fails its saving throw, it is turned for 1 minute or until it takes damage.</p>\n<p>A turned creature must spend its turns trying to move as far away from you as it can, and it can’t willingly move to a space within 30 feet of you. It also can’t take reactions. For its action, it can use only the Dash action or try to escape from an effect that prevents it from moving. If there’s nowhere to move, the creature can use the Dodge action.</p>","chat":"","unidentified":""},"source":"","activation":{"type":"action","cost":1,"condition":""},"duration":{"value":null,"units":""},"target":{"value":30,"width":null,"units":"ft","type":"enemy"},"range":{"value":null,"long":null,"units":"self"},"uses":{"value":null,"max":"","per":"","recovery":""},"consume":{"type":"","target":"","amount":null},"ability":"","actionType":"util","attackBonus":0,"chatFlavor":"","critical":{"threshold":null,"damage":""},"damage":{"parts":[],"versatile":""},"formula":"","save":{"ability":"","dc":null,"scaling":"spell"},"requirements":"","recharge":{"value":null,"charged":false},"attunement":null},"effects":[],"flags":{"magicitems":{"enabled":false,"equipped":false,"attuned":false,"charges":"0","chargeType":"c1","destroy":false,"destroyFlavorText":"reaches 0 charges: it crumbles into ashes and is destroyed.","rechargeable":false,"recharge":"0","rechargeType":"t1","rechargeUnit":"r1","sorting":"l"},"itemacro":{"macro":{"data":{"_id":null,"name":"Channel Divinity: Turn the Unholy","type":"script","author":"Tyd5yiqWrRZMvG30","img":"icons/svg/dice-target.svg","scope":"global","command":"/////////////////////////////////////////////////\n// READ FIRST\n// Requires: Callback macros ActorUpdate\n////////////////////////////////////////////////\nasync function wait(ms) { return new Promise(resolve => { setTimeout(resolve, ms); }); }\nconst lastArg = args[args.length - 1];\nconst actorD = canvas.tokens.get(lastArg.tokenId).actor;\nconst rollData = actorD.getRollData();\nconst level = rollData.classes.paladin ? rollData.classes.paladin.levels : rollData.details.cr;\nconst DC = rollData.attributes.spelldc;\nconst saveType = rollData.attributes.spellcasting;\nconst itemD = lastArg.item;\nconst sequencer = game.modules.get(\"sequencer\") ? \"true\" : \"false\";\nconsole.warn(`###### ${itemD.name} Workflow Started #####`);\nconst targetList = lastArg.targets.reduce((list, target) => {\n    if (target.actor.data.data.attributes.hp.value === 0) return list;\n    let creatureTypes = [\"undead\", \"fiend\"];\n    let undead = creatureTypes.some(i => (target.actor.data.type === \"character\" ? target.actor.data.data.details.race : target.actor.data.data.details.type.value).toLowerCase().includes(i));    \n    if (undead) list.push(target);\n    return list;\n}, []);\nif (targetList.length === 0) {\n    ui.notifications.warn(`${itemD.name} was unable to find any valid targets`);\n    let canvasList = canvas.tokens.placeables.filter(i=> i.actor.data.data.details.type != undefined).map(i=> i.actor.data.data.details.type.value);\n    console.error(`Please ensure your creature types are setup correctly for latest 5e.`);\n    console.error(`List of Non-Valid Targets`,canvasList);\n    return console.error(`##### ${itemD.name} Workflow Aborted #####`);\n}\nlet turnTargets = [];\nfor (let target of targetList) {\n    // add turn resist terms\n    let resist = [\"Turn Resistance\", \"Turn Defiance\"];\n    let getResistance = target.actor.items.find(i => resist.includes(i.name));\n    let immunity = [\"Turn Immunity\"];\n    let getImmunity = target.actor.items.find(i => immunity.includes(i.name));\n    let mon_cr = target.actor.data.type === \"character\" ? target.actor.getRollData().details.levels : target.actor.getRollData().details.cr;\n    let getAdvantage = getResistance ? { advantage: true, chatMessage: false, fastForward: true } : { chatMessage: false, fastForward: true };\n    let save = await MidiQOL.socket().executeAsGM(\"rollAbility\", { request: \"save\", targetUuid: target.actor.uuid, ability: saveType, options: getAdvantage });\n    if (getImmunity) {\n        console.warn(`=>`, `Target`, target.name, `CR`, mon_cr, `Result: Immune`);\n        turnTargets.push(`<div class=\"midi-qol-flex-container\"><div class=\"midi-qol-target-npc midi-qol-target-name\" id=\"${target.id}\">${target.name} immune</div><div><img src=\"${target.data.img}\" width=\"30\" height=\"30\" style=\"border:0px\"></div></div>`);\n    } else {\n        if (save.total < DC) {            \n            console.warn(`=>`, `Target`, target.name, `CR`, mon_cr, `DC`, DC, `Save`, save.total, `Fail`, `Result: Frightened`);\n            let gameRound = game.combat ? game.combat.round : 0;\n            let effectData = {\n                label: \"Frightened\",\n                icon: \"icons/svg/terror.svg\",\n                origin: lastArg.uuid,\n                disabled: false,\n                flags: { dae: { specialDuration: [\"isDamaged\"] } },\n                duration: { rounds: 10, seconds: 60, startRound: gameRound, startTime: game.time.worldTime },\n                changes: [{ key: `flags.midi-qol.disadvantage.ability.check.all`, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: 1, priority: 20 },\n                { key: `flags.midi-qol.disadvantage.skill.check.all`, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: 1, priority: 20 },\n                { key: `flags.midi-qol.disadvantage.attack.all`, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: 1, priority: 20 }]\n            };\n            let effect = target.actor.effects.find(i => i.data.label === game.i18n.localize(\"Frightened\"));\n            if (!effect) {\n                await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: target.actor.uuid, effects: [effectData] });\n                console.warn(`>`,target.name,`Applyying Frightened`,`Success`);\n            } else {\n                console.warn(`>`,target.name,`Already Frightened`,`Skip`);\n            }\n            if (sequencer) {\n                new Sequence()\n                    .effect()\n                    .atLocation(target)\n                    .file(\"jb2a.icon.fear.orange\")\n                    .scaleToObject(1.5)\n                .play()\n            }\n            turnTargets.push(`<div class=\"midi-qol-flex-container\"><div class=\"midi-qol-target-npc midi-qol-target-name\" id=\"${target.id}\">${target.name} fails with ${save.total}</div><div><img src=\"${target.data.img}\" width=\"30\" height=\"30\" style=\"border:0px\"></div></div>`);\n        } else {\n            console.warn(`>`, `Target`, target.name, `CR`, mon_cr, `DC`, DC, `Save`, save.total, `Result: Save`);\n            turnTargets.push(`<div class=\"midi-qol-flex-container\"><div class=\"midi-qol-target-npc midi-qol-target-name\" id=\"${target.id}\">${target.name} succeeds with ${save.total}</div><div><img src=\"${target.data.img}\" width=\"30\" height=\"30\" style=\"border:0px\"></div></div>`);\n        }\n    }\n}\nconsole.warn(`##### ${itemD.name} Workflow Completed #####`);\nawait wait(600);\nlet turn_results = `<div class=\"midi-qol-nobox midi-qol-bigger-text\">${CONFIG.DND5E.abilities[saveType]} Saving Throw: DC ${DC}</div><div><div class=\"midi-qol-nobox\">${turnTargets.join('')}</div></div>`;\nlet chatMessage = await game.messages.get(args[0].itemCardId);\nlet content = await duplicate(chatMessage.data.content);\nlet searchString = /<div class=\"midi-qol-hits-display\">[\\s\\S]*<div class=\"end-midi-qol-hits-display\">/g;\nlet replaceString = `<div class=\"midi-qol-hits-display\"><div class=\"end-midi-qol-hits-display\">${turn_results}`;\ncontent = await content.replace(searchString, replaceString);\nawait chatMessage.update({ content: content });\nawait ui.chat.scrollBottom();","folder":null,"sort":0,"permission":{"default":0},"flags":{}}}},"midi-qol":{"onUseMacroName":"[postActiveEffects]ItemMacro","forceCEOn":false,"effectActivation":false},"core":{"sourceId":"Item.elF0DorAB12P9irY"},"exportSource":{"world":"darklands","system":"dnd5e","coreVersion":"9.242","systemVersion":"1.5.6"},"midiProperties":{"nodam":false,"fulldam":false,"halfdam":false,"rollOther":false,"critOther":false,"magicdam":false,"magiceffect":false,"concentration":false,"toggleEffect":false}},"_stats":{"systemId":"dnd5e","systemVersion":"2.0.3","coreVersion":"10.290","createdTime":1669440918455,"modifiedTime":1669440918455,"lastModifiedBy":"T4cu5jv0VXcrhb1w"},"_id":"wb6g0vsE0AOjNqOi","folder":null,"sort":0,"ownership":{"default":0,"T4cu5jv0VXcrhb1w":3}}
